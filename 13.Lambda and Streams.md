<h1 align="center">
  Lambda and Streams Conceptual Questions
</h1>

## Q1. What is a Functional Interface?
A functional interface is an interface that contains only one abstract method. It can have any number of default or static methods, but it must have only one abstract method. This single abstract method is known as the functional method or the signature method.

Functional interfaces are used in Java 8 and above to support lambda expressions and method references, which are key features of functional programming in Java.

Here's an example of a functional interface in Java: 

```

@FunctionalInterface 
public interface MyFunctionalInterface { 
	int doSomething(int a, int b); 
}

```


 ## Q2. How to use Predicate Functional Interface?
 Predicate is a functional interface that represents a predicate (boolean-valued function) of one argument. It is defined in the java.util.function package and contains test() a functional method.

Consider the below example for Predicate functional interface:

```

import java.util.function.Predicate;  
public class PredicateInterfaceExample {  
    public static void main(String[] args) {  
        Predicate<Integer> pr = a -> (a > 18); // Creating predicate  
        System.out.println(pr.test(10));    // Calling Predicate method    
    }  
}  

```

## Q3. Give some examples of pre-defined Functional Interfaces.
Following are some commonly used pre-defined Functional Interfaces in Java.

| Functional Interface | Method Signature | Input Parameters | Return Values | When to use it? |
|----------------------|------------------|------------------|---------------|-----------------|
| Predicate<T> | boolean test(T t) | one | boolean | Use in conditional statements |
| Function<T, R> | R apply(T t)	| one| Any type | Use when to perform some operation & get some result |
| Consumer<T> | void accept(T t) | one	| Nothing | Use when nothing needs to be returned |
| Supplier<R> | R get()	| None	| Any type | Use when something is to be returned without passing any input |
| BiPredicte<T, U> | boolean test(T t, U u) | two | boolean | Use when Predicate needs two input parameters |
| BiFunction<T, U, R> | R apply(T t, U u) | two | Any type| Use when Function needs two input parameters |


## Q4. What are the three main components of a Stream?
In Java, a stream is a sequence of elements that can be processed in a declarative way. Streams are built upon three main components:

- **Source:** The source is where the stream gets its elements. It can be a collection, an array, or an I/O channel.
- **Intermediate operations:** These are the operations that transform the stream into another stream. Intermediate operations do not execute until a terminal operation is invoked. Some examples of intermediate operations are filter, map, and sorted.
- **Terminal operation:** This is the operation that produces a result or a side effect. Terminal operations execute the stream pipeline and produce a result. Some examples of terminal operations are forEach, reduce, and collect.

The below example shows all these 3 operations:

```

import java.util.Arrays;
import java.util.stream.Stream;
public class StreamComponents {
    public static void main(String[] args) {
        // 1. Source: This is the origin of the data for the stream.
        // Here, we create a simple array of Strings as the data source.
        String[] fruits = {"apple", "banana", "orange", "mango"};
        // 2. Intermediate Operations: These operations transform the elements
        // in the stream without actually producing a result. Here, we filter
        // fruits starting with the letter "o".
        Stream<String> filteredFruits = Arrays.stream(fruits).filter(fruit -> fruit.startsWith("o"));
        // 3. Terminal Operation: This operation consumes the elements in the stream
        // and produces a result. Here, we count the number of filtered fruits.
        long count = filteredFruits.count();
        System.out.println("Number of fruits starting with 'o': " + count);
    }
}
//Output: Number of fruits starting with 'o': 1

```

## Q5. How does parallel stream work – how does it make use of multiple cores of CPU?
In Java, the parallel stream is a feature of the Java 8 Stream API that allows processing elements of a stream concurrently, utilizing multiple CPU cores. This can lead to significant performance improvements for operations that can be parallelized, such as filtering, mapping, and reducing large data sets.

When a stream is converted to a parallel stream, Its elements are divided into several chunks and each chunk is processed on a different thread. By default, **parallelStream() creates threads whose count equals the number of processors available.**

Here is a familiar example using the parallelStream() method to retrieve a parallel stream from a collection:

```

List<Employee> lstEmp = Employee.getEmpList();
lstEmp.parallelStream().filter(emp -> emp.getYearsInOrg() < 1)
.sorted((e1, e2) -> e1.getId() - e2.getId())
.forEach((e) -> System.out.println(e.getId() + ":" + e.getName()));

```

## Q6. What is the Lambda expression in Java 8? Why do we use it? What are its advantages ?
As its name suggests it's an expression that allows you to write more succinct code in Java 8. Lambda Expression is a type of "anonymous" method, which is not bound to any identifier. And so, they do not belong to any class/type. It brings a new and important feature to Java known as "Functional Programming". A Lambda Expression enables a method to be passed as an argument to other methods, as and when required.

The syntax for Lambda Expression is as follows:

```

( arguments ) -> { body }

```

#### Example:

```

// Traditional anonymous class for sorting 
List<Integer> numbers = Arrays.asList(3, 1, 4, 5, 2);
numbers.sort(new Comparator<Integer>() {
	@Override
	public int compare(Integer num1, Integer num2) {
		return num1 - num2;
	}
});
	
// Using a lambda expression for sorting
List<Integer> numbers = Arrays.asList(3, 1, 4, 5, 2);
numbers.sort((num1, num2) -> num1 - num2);

```

#### There are several reasons to use lambda expressions in Java:
- Conciseness
- Improved readability
- Functional programming

#### Advantages of Lambda Expressions:
- Reduced boilerplate code
- Enhanced collections framework
- Stream API integration


 ## Q7. What is method reference in Lambda?
 A method reference is a shortcut of the lambda expression. It further cut down the boilerplate and makes your code more readable. If you have a method that already does what you are doing in lambda expression then you can use method reference in place of lambda expression. For example, if you have a list of integers and you are just printing their values like the below:

```

list.forEach(i -> System.out.println(i));

```

then you can replace this lambda expression with method reference because System.out.println() already does this i.e. take an argument and prints it. Here is the equivalent code using method reference:

```

list.forEach(System.out::println);

```

Remember, the double colon operator (::) is used for method reference in Java 8.


## Q8. Can we write more than one line of code in lambda expression?
Yes, we can write more than online of code in lambda expression using curly braces, similar to how you define static initializer block. 

Here is an example of a lambda expression which is longer than one line:

```

(String first, String second) -> { if(first.equals(second)){    return true;  }else{    return false;  } };

```

One important thing to note in this case is the return statement, which is mandatory here, unlike one-liner lambda where you can just omit them most of the time. 

## Q9. Can a functional interface extend/inherit another interface?
A functional interface cannot extend another interface with abstract methods as it will void the rule of one abstract method per functional interface. 

It can extend other interfaces that do not have any abstract method and only have the default, static.


## Q10. What does the map() function do? What is its use?
- The map() function performs map functional operation in Java. This means it can transform one type of object into another by applying a function.
- For example, if you have a List of String and you want to convert that to a List of Integer, you can use map() to do so.
- Just supply a function to convert String to Integer e.g., parseInt() to map() and it will apply that to all elements of List and give you a List of Integer. In other words, the map can convert one object to another.

##### Example:

```

public class MapExample {
	public static void main(String[] args) {
		Integer[] numbers = {1, 2, 3, 4, 5};
		System.out.println("Original numbers: " + java.util.Arrays.toString(numbers));
		Integer[] squaredNumbers = java.util.stream.Stream.of(numbers)
				.map(number -> number * number)
				.toArray(Integer[]::new);
		System.out.println("Squared numbers: " + java.util.Arrays.toString(squaredNumbers));
		System.out.println("\nExplanation:");
		System.out.println(" - The map() function is used to transform each element in a stream.");
		System.out.println(" - It takes a lambda expression (a small anonymous function) as an argument.");
		System.out.println(" - The lambda expression defines the transformation to be applied to each element.");
		System.out.println(" - In this example, the lambda expression (number -> number * number) squares each number.");
		System.out.println(" - map() returns a new stream containing the transformed elements.");
	}
}

```

##### Output:

Original numbers: [1, 2, 3, 4, 5] <br>
Squared numbers: [1, 4, 9, 16, 25]

#### Explanation:
- The map() function is used to transform each element in a stream.
- It takes a lambda expression (a small anonymous function) as an argument.
- The lambda expression defines the transformation to be applied to each element.
- In the above example, the lambda expression (number -> number * number) squares each number.
- map() returns a new stream containing the transformed elements.


## Q11. What does the filter() method do? When is it used?
- The filter method is used to filter elements that satisfy a certain condition that is specified using a Predicate function. 
- A predicate function is nothing but a function that takes an Object and returns a boolean. For example, if you have a List of Integers and you want a list of even integers. 
- In this case, you can use the filter to achieve that. You supply a function to check if a number is even or odd, just like this function, and the filter will apply this to stream elements and filter the elements which satisfy the condition and which don't.

##### Example:

```

import java.util.ArrayList;
import java.util.List;
public class StreamFilterExample {
    public static void main(String[] args) {
        // Create a list of numbers
        List<Integer> numbers = new ArrayList<>();
        numbers.add(1);
        numbers.add(2);
        numbers.add(3);
        numbers.add(4);
        numbers.add(5);
        List<Integer> evenNumbers = numbers.stream()
                .filter(number -> number % 2 == 0) 
                .toList(); 
        System.out.println("Even numbers: " + evenNumbers);
    }
}
// Output: Even numbers: [2, 4]

```

## Q12. What is the difference between flatMap() and map() functions?
- Even though both map() and flatMap() can be used to transform one object to another by applying a method to each element.

- The main difference is that flatMap() can also flatten the Stream. For example, if you have a list of the list, then you can convert it to a big list by using the flatMap() function.


## Q13. What do you mean by saying Stream is lazy?
It is an important characteristic of streams because the operation on the source data is only performed when the terminal operation is initiated. It doesn’t consume the source elements as in eager loading, the source elements are consumed only on demand.

As you have seen in Stream operations:

- The intermediate operations are lazy in nature and only executed when a result of processing is needed.
- Intermediate operations don’t produce the result. It creates a new stream.
- Intermediate operations are not evaluated until the terminal operations are not initiated.
- When a terminal operation is initiated, the traversal of streams starts, and the associated function is performed one by one.
 

## Q14. Do you need to specify the type for parameters in a lambda expression?
In most cases, you do not need to specify the type of parameters in a lambda expression. The java compiler infers the type for the parameters by matching them with the parameter types of the abstract method of the functional interface.
