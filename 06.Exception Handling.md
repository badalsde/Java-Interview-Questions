<h1 align="center">
  Exception Handling Conceptual Questions
</h1>


## Q1. Explain Exception handling and its concepts.
In Java, exceptions are unexpected events that occur during the execution of a program, disrupting its normal flow.

In Java, the **Throwable** class is the base class for all Exceptions and Errors.

**Error:** 

- These are serious problems that typically indicate a fatal issue within the Java Virtual Machine (JVM) or the environment itself.
- They're not expected to be recovered from within your program's code. Examples include OutOfMemoryError.

### Exception:

These represent recoverable exceptions that can be handled by your code. They are further divided into two categories:

1. **Checked Exceptions:** - These exceptions typically represent issues that can be reasonably anticipated and recovered from during program execution. The Java compiler forces you to either declare them in the throws clause of a method or use a try-catch block to handle them. Examples include IOException (for file I/O problems). 
2. **Unchecked Exceptions:** - These exceptions often represent programming errors or unexpected conditions that might be difficult to anticipate at compile time. The compiler doesn't require you to handle them explicitly (but you can if you choose to). Examples include NullPointerException (for accessing a null object), and ArithmeticException (for division by zero).
- We can use the 'try-catch-finally' blocks to gracefully handle exceptions and prevent our program from crashing. 
- The 'try' block contains the code that we want to monitor for exceptions. If an exception occurs within the 'try' block, the program exits the block and searches for a corresponding 'catch' block." 
- The 'catch' block allows us to define how our program should respond to a specific type of exception. 
- The 'finally' block is always executed, whether an exception occurs or not. This block is used to perform cleanup activities, such as closing files or releasing resources.

#### Example:

```

public void readFile(String filename) {
    try {
        Scanner scanner = new Scanner(new File(filename)); // Potential for FileNotFoundException
        // Process the file contents using the scanner
        scanner.close(); // Potential for IOException
    } catch (FileNotFoundException e) {
        System.err.println("Error: File not found - " + filename);
    } catch (IOException e) {
        System.err.println("Error: An I/O error occurred while reading the file.");
    }
}

```

Java allows you to create your own custom exceptions, also known as user-defined exceptions, to handle specific error scenarios in your application.

#### Example:

```

public class AgeException extends Exception { // Inherits from Exception (checked)
    public AgeException(String message) {
        super(message); // Call parent constructor with message
    }
}

```

- Throwing Exceptions:

  Within our code, we can use the throw keyword followed by an instance of our custom/Java exception class to signal an error condition.

#### Example:

```

public void validateAge(int age) throws AgeException {
    if (age < 0) {
        throw new AgeException("Age cannot be negative."); // Throwing custom exception
    }
}

```

- The throws Clause:

  If a method throws a checked exception, you can declare it in the throws clause of the method signature. This informs the caller that the method might throw that specific exception type.
The throws clause is not mandatory for unchecked exceptions because the compiler doesn't require explicit handling.

##### Example:

```

public void validateAge(int age) throws AgeException { // Declared in method signature
    // ... validation logic ...
}

```

## Q2. What is try with resources?  In which Java version was it introduced?​
"Try-with-resources" was introduced with Java 7. It simplifies the process of working with resources that require explicit closing, such as file streams or database connections.
Only  object that implements java.lang.AutoCloseable can be used as a resource.​

Before the introduction of "try-with-resources," developers had to manually close the resources they used, usually in a "finally" block.

This code is verbose and error-prone, as the developer must remember to close the resource in the finally block and handle any potential exceptions that may arise during the closing process.
"Try-with-resources" simplifies this process by automatically closing the resources at the end of the block, even if an exception is thrown.

The syntax looks like this:

```

try (InputStream inputStream = new FileInputStream("myfile.txt")) { 
// use inputStream to read from file
 } catch (IOException e) { 
// handle exception 
}

```


## Q3. What is a finally block?
A “finally” block is a code block that is used in conjunction with try-catch blocks in exception handling to specify a set of statements that should be executed regardless of whether an exception is thrown or not. This ensures that important tasks such as closing a database connection or releasing a resource are always executed, regardless of any errors that may occur in the preceding “try” block.
Here's the basic syntax of a try-catch-finally block:

```

try { 
// code that might throw an exception 
} 
catch (ExceptionType ex) { 
// code to handle the exception 
} 
finally { 
// code that will be executed regardless of whether an exception was thrown or not
 }

```


## Q4. What is the difference between “No Class Definition Found” and “Class Not Found” Exceptions?
Both "ClassNotFound" and "NoClassDefinitionFound" are exceptions that occur in Java when the Java Virtual Machine (JVM) cannot find a particular class that is required to run a program. However, there is a subtle difference between the two:

- **"ClassNotFoundException":** This exception is thrown when the JVM tries to load a class at runtime, but the specified class cannot be found in the classpath. This can happen when the name of the class is misspelled, or when the class is not available in the classpath or package.
- **"NoClassDefinitionFound":** This exception is thrown when the JVM tries to load a class that was available during compilation time but is no longer available during runtime. This could happen if the classpath has changed or if a required jar or class file has been deleted or moved to another location.


## Q5. How to recover from a ClassNotFoundException?  ​
A "Class not found" exception occurs when the class loader is unable to find a particular class at runtime. To recover from this exception, we can take the following steps:

1. Make sure that the class name is spelled correctly and that the package name is correct.
2. Ensure that the class is present in the class path. The classpath is a list of directories and JAR files that the JVM searches when loading classes.
3. Sometimes, a class may depend on other classes that are not present in the classpath. Ensure that all the required dependencies are present in the classpath.
4. Check the version of the class: If you have multiple versions of the same class in the classpath, ensure that you are using the correct version.
5. Reload the class: If the class has been dynamically loaded, you can try to reload it by creating a new instance of the class using reflection.
6. If all else fails, you can try to recompile the code to ensure that the class is present in the classpath.


## Q6. How to recover from a NoClassDefinitionFoundException?​
A "No class definition found" error typically occurs when the Java Virtual Machine (JVM) cannot find the class you are trying to use or load. Here are some steps you can take to recover from this error:

1. Check your classpath: Make sure that the class you are trying to use or load is in the classpath. If it is not, add it to the classpath.
2. Check the class name: Verify that you have spelled the class name correctly and that the package name is correct.
3. Check the package declaration: Verify that the package declaration at the beginning of the Java file matches the directory structure where the Java file is located.
4. Check for conflicting versions.
5. Check for missing dependencies: If the class you are trying to use depends on other classes or libraries, make sure those dependencies are also in the classpath.
6. Check for errors in the class: If there are errors in the class code, such as syntax errors or missing dependencies, the class may not be able to load. Fix any errors in the class code.
 

## Q7. Is it possible to override a method to throw RuntimeException from throwing NullPointerException in the parent class?
Yes, this is possible. But it is not possible if the parent class has a checked Exception. This is due to the below rule of method overriding in cases of checked exceptions:

The method that wants to override a parent class method cannot throw a higher Exception than the overridden method.

This means that if the overridden method is throwing IOException, then the overriding child class method can only throw IOException or its sub-classes. This overriding method can not throw a higher Exception than the original or overridden method.

Here is a complete example:

```

class Parent {
	public void checkObject(Object obj) throws NullPointerException {
		if (obj == null) {
			throw new NullPointerException("Object cannot be null");
		}
		System.out.println("Object is valid: " + obj);
	}
}
class Child extends Parent {
	public void checkObject(Object obj) throws RuntimeException {
		if (obj == null) {
			throw new RuntimeException("Critical failure: Object is null");
		}
		System.out.println("Object is valid: " + obj);
	}
}
public class Main {
	public static void main(String[] args) {
		Parent parent = new Parent();
		Child child = new Child();
		try {
			parent.checkObject(null);
		} catch (NullPointerException e) {
			System.out.println("Parent caught: " + e.getMessage());
		}
		try {
			child.checkObject(null);
		} catch (RuntimeException e) {
			System.out.println("Child caught: " + e.getMessage());
		}
	}
}

```

Output:

Parent caught: Object cannot be null<br>
Child caught: Critical failure: Object is null


## Q8. What is the difference between an error and an exception in Java?
**Errors** are mainly caused by the environment in which an application is running. 
- For example, OutOfMemoryError happens when JVM runs out of memory. 

**Exceptions** are mainly caused by the application itself. 
- For example, NullPointerException occurs when an application tries to access the null object. 


## Q9. What are checked and unchecked exceptions in Java?
- **Checked exceptions** are the exceptions that are known to the compiler. These exceptions are checked at compile time only. Hence the name-checked exceptions. These exceptions are also called compile-time exceptions, as these exceptions will be known during compile time itself.
- **Unchecked exceptions** are those exceptions that are not at all known to the compiler. These exceptions occur only at run time. These exceptions are also called as run time exceptions. All subclasses of java.lang.RunTimeException and java.lang.Error are unchecked exceptions.


## 10. What is a user-defined exception?
In Java, a user-defined exception is a custom exception that you can create to handle specific error scenarios in your code. You can define your own exception class by extending the Exception class in Java.

Here is an example of a user-defined exception in Java:

```

class MyException extends Exception {
    public MyException(String s)
    {
        // Call constructor of parent Exception
        super(s);
    }
}
// A Class that uses above MyException
public class Main {
    // Driver Program
    public static void main(String args[])
    {
        try {
            // Throw an object of user defined exception
            throw new MyException("GeeksGeeks");
        }
        catch (MyException ex) {
            System.out.println("Caught");
 
            // Print the message from MyException object
            System.out.println(ex.getMessage());
        }
    }
}

```



## Q11. What is exception chaining in Java?
In Java, exception chaining is a mechanism that allows one exception to be linked to another, thereby creating a chain of exceptions that can provide more detailed information about an error. This is done using the initCause method of the Throwable class. 

Here's an example of how to use exception chaining in Java: 

```

public class ExceptionChainingExample {
    public static void main(String[] args) {
        try {
            // Call a method that throws an exception
            divide(10, 0);
        } catch (ArithmeticException e) {
            // Wrap the original exception with a new one, providing more context
            throw new RuntimeException("An error occurred while dividing", e);
        }
    }
    public static int divide(int numerator, int denominator) {
        if (denominator == 0) {
            throw new ArithmeticException("Division by zero");
        }
        return numerator / denominator;
    }
  }

```


## Q12. What Is the Purpose of the Throw and Throws Keywords
The **throws** keyword is used to specify that a method may raise an exception during its execution. It enforces explicit exception handling when calling a method.

The **throw** keyword allows us to throw an exception object to interrupt the normal flow of the program. This is most commonly used when a program fails to satisfy a given condition.


Example with the usage of throw and throws keyword:

```

public class AgeValidator {
	public static void validateAge(int age) throws InvalidAgeException {
		if (age < 18) {
			throw new InvalidAgeException("Age must be 18 or older.");
		}
		System.out.println("Valid age!");
	}
	public static class InvalidAgeException extends Exception {
		public InvalidAgeException(String message) {
			super(message);
		}
	}
	public static void main(String[] args) {
		try {
			validateAge(20);
		} catch (InvalidAgeException e) {
			System.err.println("Error: " + e.getMessage());
		}
		try {
			validateAge(15); // This will throw the exception
		} catch (InvalidAgeException e) {
			System.err.println("Error: " + e.getMessage());
		}
	}
}
/*
Output:
Valid age!
Error: Age must be 18 or older.
*/

```


## Q13. Can we use try without catch?
**Yes,** we can use a try block without any catch block, but it must be **followed either by a finally block or be part of a try-with-resources** statement.

**Example1:** try block with finally block

```

public static void main(String[] args) throws IOException {
		FileInputStream file = new FileInputStream("input.txt");
		try {
			// Code that might throw an exception
			int data = file.read();
			System.out.println("Data read from file: " + data);
		} finally {
			// Clean-up code, like closing the file
			System.out.println("Closing the file");
			if (file != null) {
				file.close();
			}
		}
	}

```

**Example2:** try block as a part of try-with-resources statement

```

public static void main(String[] args) throws IOException {
		try (FileInputStream file = new FileInputStream("input.txt")) {
			int data = file.read();
			System.out.println("Data read from file: " + data);
		}
	}

```


## Q14. Explain final, finally, and finalize().
#### final:

The keyword ‘final’ is used in Java to restrict the modification of a variable, method, or class. A final variable cannot be modified. A final method in the parent class cannot be overridden in the child class. A final class cannot be extended by any class.

#### Example:

```

public class DemoClass {
	final int age = 18;
	public void modifyAge() {
		age = 20;//Error: The final field DemoClass.age cannot be assigned
	}
	public static void main(String[] args) {
//Main method implemented
	}	
}

```

#### finally:

The ‘finally’ block is used following the try/catch block to ensure that a section of code is always executed regardless of whether an exception occurs or not.


##### Example:

```

public class DemoClass {
	public static void main(String[] args) {
		try {
			int a = 10 / 20; // Case1: without exception
			// int a = 10 / 0;//Case2: with exception
		} catch (ArithmeticException e) {
			System.out.println("Catch block is executed.");
		} finally {
			System.out.println("Finally block is executed.");
		}
	}
}

```

Output for Case1: <br>
Finally block is executed.


Output for Case2:<br>
Catch block is executed.<br>
Finally block is executed.
 

#### finalize():

The ‘finalize’ is a method in Java used to perform cleanup operations on an object such as closing files or releasing other resources, before it is garbage collected.


##### Example:

```

public class DemoClass {
	public static void main(String[] args) {
		DemoClass obj = new DemoClass();
		System.out.println("Hashcode is: " + obj.hashCode());// printing the hashcode
		obj = null; // this object will be garbage collected
		System.gc();// calling the garbage collector using gc()
	}
	// Defining the finalize method
	@Override
	protected void finalize() {
		System.out.println("Cleanup code in finalize() method is executed");
	}
}

```

**Output:**<br>
Hashcode is: 1023487453<br>
Cleanup code in finalize() method is executed


## Q15. Can we have multiple catch blocks with try statement?
**Yes,** starting from Java 7.0, it is possible for a single catch block to handle multiple exceptions by separating each exception type with a ‘|’ (pipe symbol) in the catch block.

```

import java.util.Scanner;
public class Test
{
    public static void main(String args[])
    {
        Scanner scn = new Scanner(System.in);
        try
        {
            int n = Integer.parseInt(scn.nextLine());
            if (99%n == 0)
                System.out.println(n + " is a factor of 99");
        }
        catch (NumberFormatException | ArithmeticException ex)
        {
            System.out.println("Exception encountered " + ex);
        }
    }
}

```

```

Input: HelloWorld
Output: Exception encountered java.lang.NumberFormatException: For input string: "HelloWorld"

```


## Q16. What are the Best Practices in Exception Handling?
Some of the best practices are:

- Use Specific Exception Classes depending on the type of exception thrown by the code
- Catch Exceptions at the Appropriate Level of Abstraction
- Log and Handle Exceptions in a Consistent and Informative Manner
- Avoid Empty Catch Blocks and Swallowing Exceptions
- Use finally Blocks for Cleanup and Resource Management
- Choose Between Checked and Unchecked Exceptions Based on the Situation


## Q17. What is ConcurrentModificationException in Java?
In Java, ConcurrentModificationException is a runtime exception that occurs when you try to modify a collection (like an ArrayList, HashMap, etc.) while you're iterating over it using an iterator. This can happen in two main scenarios:

- Multithreaded environment: If one thread is iterating over a collection using an iterator, and another thread tries to add, remove, or change elements in that collection, you'll likely get this exception.
- Single-threaded environment: Even in a single thread, if you modify the collection directly while iterating over it with a fail-fast iterator, the exception can be thrown.

Here are some ways to avoid ConcurrentModificationException:

- Use the iterator.remove() method: This is the safe way to remove elements from a collection while iterating over it.
- Make a copy of the collection: If you need to modify the collection while iterating, create a copy of it and iterate over the copy instead.
- Use concurrent collections: Java provides special concurrent collection classes like CopyOnWriteArrayList that are designed for use in multithreaded environments. These collections handle modifications safely and won't throw this exception.

(Fail-fast: if you try to modify the collection while iterating, the iterator will throw this exception to signal that the results of the iteration are no longer reliable. This helps to prevent unexpected behavior and potential errors in your code.)
