<h1 align="center">
  Object Class Conceptual Questions
</h1>


## Q1. How to compare two objects in Java?
The Java Object class provides two important methods equals() and hashCode() which a class must override to compare its two objects.

- **equals() method:**
  - It compares the references of two objects and returns true if the two objects are the same object in memory. 
  - This default implementation may not be suitable for all classes. For example, if we have a class Person with fields such as name, age, we may want to define equality based on these field values, rather than on the memory location of the object. 
  - Therefore, if you want to compare the contents of two objects of the same class, you must override the equals method to define the comparison based on the content of the objects.

- **hashCode() method:**

  - This method is used to generate a unique integer value for an object. This value is used to store the object in a hash table, which allows a fast lookup of objects based on their hash code.
  - If you do not override the hashCode method, the default implementation provided by the Object class simply returns a unique identifier for each object, which is not based on the contents of the object. 
  - This can lead to situations where two objects that are equal according to their equals method return different hash codes, which can cause problems when the objects are used in hash-based data structures like HashMap or HashSet.

Therefore, it is important to override both the equals and hashCode methods when comparing objects in Java to ensure that objects with the same content are treated as equal and have the same hash code. 

```

public class Person {
	private String name; 
	private int age; 
	public Person(String name, int age) {
		 this.name = name; this.age = age; } 
     @Override
	 public boolean equals(Object o) {
	 	Person otherPerson = (Person) o;
		 return this.age == otherPerson.age; } 
	@Override
	public int hashCode() { 
		return Objects.hash(name, age); } 
}

```


## Q2. What is the Object class?
- Object class defined in java.lang package is the superclass of all other classes defined in the Java programming language. Every class extends the Object class implicitly. All classes inherit the instance methods defined in the Object class.
- Object class defines eight non-static methods that are inherited by all other classes. A Java class can override any of these eight methods.
- The methods are: clone(), toString(), equals(), hashcode(), finalize(),getClass(), wait(), notify(), notifyAll()


## Q3. What is hashCode() and equals() method? 
The equals() and hashcode() are the two important methods provided by the Object class for comparing objects. Since the Object class is the parent class for all Java objects, hence all objects inherit the default implementation of these two methods.

Java equals():

- The java equals() is a method of Java.lang.Object class, and it is used to compare two objects.
- The default implementation of equals method is defined in Java.lang.Object class which simply checks if two Object references (say x and y) refer to the same Object. i.e. It checks if x == y. Since Object class has no data members that define its state, it is also known as shallow comparison.
- Suppose a class provides its own implementation of equals() method in order to compare the Objects of that class w.r.t state of the Objects. That means data members (i.e. fields) of Objects are to be compared with one another. Such Comparison based on data members is known as deep comparison.

Java hashCode():

- A hashcode is an integer value associated with every object in Java, facilitating the hashing in hash tables.
- hashCode() method returns the hashcode value as an Integer. 
- Hashcode value is mostly used in hashing-based collections like HashMap, HashSet, HashTable….etc. 
- Since this method is defined in the Object class, hence it is inherited by user-defined classes also.
- The hashCode() method returns the same hash value when called on two objects, which are equal according to the equals() method. And if the objects are unequal, it usually returns different hashcode values.
- This method must be overridden in every class that overrides the equals() method.
 

#### Example:

```

class Person {
	private String name;
	private int age;
	public Person(String name, int age) {
		super();
		this.name = name;
		this.age = age;
	}
	@Override
	public int hashCode() {
		return Objects.hash(age, name);
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Person other = (Person) obj;
		return age == other.age && Objects.equals(name, other.name);
	}
}
public class MainClass {
	public static void main(String[] args) {
		Person person1 = new Person("John", 30);
		Person person2 = new Person("John", 30);
		Person person3 = new Person("Sam", 40);
		System.out.println("person1.equals(person2) = " + person1.equals(person2));
		System.out.println("person1.equals(person3) = " + person1.equals(person3));
		System.out.println("person1.hashCode() = " + person1.hashCode());
		System.out.println("person2.hashCode() = " + person2.hashCode());
		System.out.println("person3.hashCode() = " + person3.hashCode());
	}
}

```

**Output:**<br>
person1.equals(person2) = true<br>
person1.equals(person3) = false<br>
person1.hashCode() = 2316430<br>
person2.hashCode() = 2316430<br>
person3.hashCode() = 85080<br>

In the above example, equals() and hashCode() methods are overridden. The equals() method now compares the values of fields associated with the two objects. As the objects person1 and person2 are equal, their hashcode values are also same. As the objects person1 and person3 are different, their hashcode values are also different.


## Q4. How JVM checks hashcode internally?
The JVM typically uses a hashing algorithm internally to compute the hashcode of objects. The exact algorithm used may vary between different implementations of the JVM, but it generally involves converting the memory address of the object into a numerical value. 

- When an object's hashCode() method is called, the JVM may perform operations such as bitwise operations or mathematical calculations on the object's memory address to generate a unique hashcode for that object. 
- While the default implementation of hashCode() method provided by the Object class uses the memory address of the object, classes can override this method to provide their custom implementation based on the object’s state.

##### Example: With the default hashCode() method

```

class Person {
	private String name;
	private int age;
	public Person(String name, int age) {
		super();
		this.name = name;
		this.age = age;
	}
}
public class MainClass {
	public static void main(String[] args) {
		Person person = new Person("John", 30);
		System.out.println("Hashcode with default hashCode() = " + person.hashCode());
	}
}

```

Output:<br>
Hashcode with default hashCode() = 1865127310
 

##### Example2: With overridden hashCode() method

```

class Person {
	private String name;
	private int age;
	public Person(String name, int age) {
		super();
		this.name = name;
		this.age = age;
	}
	@Override
	public int hashCode() {
		return Objects.hash(age, name);
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Person other = (Person) obj;
		return age == other.age && Objects.equals(name, other.name);
	}
}
public class MainClass {
	public static void main(String[] args) {
		Person person = new Person("John", 30);
		System.out.println("Hashcode with overridden hashCode() = " + person.hashCode());
	}
}

```

Output:<br>
Hashcode with overridden hashCode() = 2316430


## Q5. Explain Object class methods.
Here are the common methods from the Object class in Java and their descriptions.

| Method | Description | 
|--------|-------------|
| public final Class getClass() | returns the Class class object of this object. The Class class can further be used to get the metadata of this class. |
| public int hashCode() | returns the hashcode number for this object. |
| public boolean equals(Object obj) | compares the given object to this object. |
| protected Object clone() throws CloneNotSupportedException | creates and returns the exact copy (clone) of this object. |
| public String toString() | returns the string representation of this object. |
| public final void notify() | wakes up single thread, waiting on this object's monitor. |
| public final void notifyAll() | wakes up all the threads, waiting on this object's monitor. |
| public final void wait(long timeout)throws InterruptedException | causes the current thread to wait for the specified milliseconds, until another thread notifies (invokes notify() or notifyAll() method). |
| public final void wait(long timeout,int nanos)throws InterruptedException | causes the current thread to wait for the specified milliseconds and nanoseconds, until another thread notifies (invokes notify() or notifyAll() method). |
| public final void wait()throws InterruptedException | causes the current thread to wait, until another thread notifies (invokes notify() or notifyAll() method). |
| protected void finalize()throws | Throwable	is invoked by the garbage collector before object is being garbage collected. |

##### Example:

```

class Person implements Cloneable {
	private String name;
	private int age;
	public Person(String name, int age) {
		super();
		this.name = name;
		this.age = age;
	}
	@Override
	public Object clone() throws CloneNotSupportedException {
		return super.clone();
	}
	@Override
	public String toString() {
		return "Person [name=" + name + ", age=" + age + "]";
	}
}
public class MainClass {
	public static void main(String[] args) throws CloneNotSupportedException {
		Person person1 = new Person("John", 30);
		Person person2 = new Person("John", 30);
		Person person3 = new Person("Sam", 40);
		System.out.println("Class name for person1: " + person1.getClass().getName());
		System.out.println("person1.equals(person2) = " + person1.equals(person2));
		System.out.println("person1.equals(person3) = " + person1.equals(person3));
		System.out.println("person1.hashCode() = " + person1.hashCode());
		System.out.println("person2.hashCode() = " + person2.hashCode());
		System.out.println("person3.hashCode() = " + person3.hashCode());
		Person person4 = (Person) person1.clone();
		System.out.println("Clone object person4: " + person4);
	}
}

```

**Output:**<br>
Class name for person1: com.infy.demo.Person<br>
person1.equals(person2) = false<br>
person1.equals(person3) = false<br>
person1.hashCode() = 1651191114<br>
person2.hashCode() = 1586600255<br>
person3.hashCode() = 474675244<br>
Clone object person4: Person [name=John, age=30]<br>

## Q6. What is the difference between equals() and == ?
- **equals() method:** This method compares the value or content of two objects. When using the equals() method, two objects will be equal if their corresponding fields or data are the same. The equals() method is defined in the Object class but can be overridden by subclasses to provide a specific comparison logic for those objects.
- **== operator:** This operator compares the memory location of two objects. It essentially checks if both objects refer to the same object in memory.

Example:

```

String str1 = "hello";
String str2 = "hello";
String str3 = new String("hello");
System.out.println(str1 == str2); // true (same memory location)
System.out.println(str1.equals(str3)); // true (same content)
System.out.println(str1 == str3); // false (different memory locations)

```
