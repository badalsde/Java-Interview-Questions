<h1 align="center">
    Java Basics Conceptual Questions
</h1>

## Q1. What are the features of Java 7?
Some of the key features of Java 7 are:
- **Switch statement with Strings:** Now, switch statements can use Strings instead of just numbers or characters.
- **Automatic resource management:** Java 7 introduced try-with-resources, a new syntax that automatically closes resources such as files, sockets, and database connections when they are no longer needed.
- **Type inference:** It added support for type inference, which allows the compiler to determine the type of a variable automatically based on its initialization.
- **Improved exception handling:** added multi-catch functionality, which allows a single catch block to handle multiple exceptions.
- **Improved performance:** Java 7 includes several performance improvements such as a G1 garbage collector and support for multicore processors.
- **Fork/Join Framework:** Java 7 introduced the Fork/Join framework, which provides a way to parallelize recursive algorithms using a divide-and-conquer approach.
- **New I/O APIs:** Java 7 includes several new I/O APIs such as the Path API, which provides a more flexible way to work with file paths, and the WatchService API, which allows applications to monitor file system events.

## Q2. What are the features of Java 8?
Java 8 is a major release of the Java programming language and includes many new features and enhancements. Some of the key features of Java 8 are:

- **Lambda Expressions:** They allow for functional programming by providing a concise way to represent anonymous functions.
- **Stream API:** The Stream API provides a new way to work with collections in Java. It enables developers to perform parallel and sequential operations on collections in a functional way.
- **Default Methods:** Default methods allow interfaces to have method implementations. This allows for backward compatibility while adding new functionality to interfaces.
- **Date and Time API:** The new Date and Time API provides a more robust and developer-friendly way to work with date and time values.
- **Method References:** Method references provide a way to refer to methods or constructors without invoking them. This feature simplifies code by allowing developers to pass methods as arguments or return them as values.
- **Optional Class:** The Optional class provides a way to handle null values in a more concise and safe manner.
- **Nashorn JavaScript Engine:** Nashorn is a lightweight and high-performance JavaScript engine that is included with Java 8. It allows developers to execute JavaScript code within the JVM.
- **Parallel Array Sorting:** The Arrays class includes new methods for sorting arrays in parallel, which can significantly improve performance on multi-core systems.

Overall, Java 8 introduces many new features that improve the expressiveness, efficiency, and safety of Java programming.

## Q3. How to restrict the override of a method in a class?
- To restrict the override of a method in a class, we must declare the method with the **final** keyword.
- When a method is declared as final in a class, it cannot be overridden by any subclass. 
- Any attempt to do so will result in a compilation error. 
- Here's an example of how to use the **final** keyword to restrict method overriding:
```
class MyClass {
	public final void myMethod() {
		System.out.println("This method cannot be overridden in subclasses.");
	}
}
class SubClass extends MyClass {
	// Attempting to override myMethod() will result in a compilation error
	public void myMethod() {
		System.out.println("This will cause a compilation error");
	}
}
public class Main {
	public static void main(String[] args) {
		MyClass obj = new MyClass();
		obj.myMethod(); // Output: This method cannot be overridden in subclasses.
	}
}
```

## Q4.  Explain Serialization and Deserialization.
In Java, serialization is the process of converting an object into a sequence of bytes, which can be saved to a file, sent over a network, or stored in a database. The serialized object contains information about the object's class, as well as its instance variables and their values.

Java provides a built-in mechanism for serialization through the Serializable interface. When a class implements Serializable, it indicates to the Java runtime that objects of that class can be serialized.

- The serialization process is then performed using the ObjectOutputStream class, which writes the object's state to an output stream.
- The deserialization process is performed using the ObjectInputStream class, which reads the object's state from an input stream and reconstructs the original object.
 
Have an observation on the following snippet that serializes a Student object:
```
FileOutputStream outFile = new FileOutputStream("StudentData.bin");
Student student=new Student(20156,"Peter","Johnson","29/05/1995",23);
ObjectOutputStream objStream = new ObjectOutputStream(outFile);
objStream.writeObject(student);
objStream.close();
outFile.close();
```
The following snippet Deserializes the Student object:
```
FileInputStream inFile = new FileInputStream("StudentData.bin");
ObjectInputStream objStream = new ObjectInputStream(inFile);
Student student = (Student) objStream.readObject();
objStream.close();
inFile.close();
```

## Q5. Can main method be overloaded in Java?
Technically, yes, you can overload the main method in Java. This means you can define multiple methods with the same name main but different parameter lists. However, there are some key points to consider:
- JVM behavior: The Java Virtual Machine (JVM) only recognizes the main method with a specific signature: public static void main(String[] args). This is the entry point for program execution.
- Overloaded methods won't be called by JVM: Any other overloaded main methods you define won't be called directly by the JVM.

#### Here's what happens:
- Your code can compile successfully even with overloaded main methods.
- When you run the program, the JVM searches for the main method with the specific signature mentioned above.
- If it doesn't find that specific signature, the program fails to run.

#### Example:
```
public class Tester {
    public static void main(String[] args) {
        System.out.println("This is the main method with String[] args");
    }
    public static void main(int num) { // Overloaded main method (won't be called by JVM)
        System.out.println("This overloaded main method won't be executed directly");
    }
    public static void main() { // Overloaded main method (won't be called by JVM)
        System.out.println("This overloaded main method (no args) won't be executed directly");
    }
}
```
```
Output: This is the main method with String[] args
```

## Q6. What happens if you use final keyword with the parameter of a method?
In Java, using the final keyword with a method parameter restricts the ability to modify the value of that parameter within the method itself.

- For primitive data types (like int, double, etc.), the final keyword doesn't have a significant effect because these types are passed by value. Any changes made to the parameter within the method operate on a copy of the original value.
- For object references (like String, custom objects, etc.), the final keyword becomes more relevant. It prevents from re-assigning the parameter to reference a different object within the method. However, we can still modify the contents of the object itself if the object is mutable.
- The final keyword primarily enhances code readability and prevents accidental modifications within the method. It doesn't guarantee immutability of the object itself.

#### Example:
```
public class StreamDemo {
	public static void modifyString(final String str) {
		// str = "Modified String"; // This would cause a compile-time error
		// (reassigning final parameter)
		System.out.println(str.toUpperCase()); // This is allowed (modifying the object's state)
		System.out.println(str);
	}
	public static void modifyArray(final int[] arr) {
		arr[0] = 100; // This is allowed (modifying element of the array object)
	}
	public static void main(String args[]) {
		int a[] = { 10, 20, 30, 40 };
		modifyString("Infosys");
		modifyArray(a);
		System.out.println(a[0]);
	}
}
```
```
Output:
INFOSYS
Infosys
100
```

## Q7. Why do we say Java is a strongly typed language? If itâ€™s strongly typed, why do we get ClassCastException? 
Java is a strongly typed language, and class cast exceptions are a consequence of that strong typing. Here's how they connect:

### Strongly Typed in Java:
- In Java, every variable has a declared type that specifies the kind of data it can hold (e.g., int, String, Object).
- The compiler strictly enforces type compatibility during compilation. This means you cannot assign values of one type to variables of another incompatible type without explicit casting.

### Benefits of Strong Typing:
- Reduces runtime errors: By catching type mismatches at compile time, Java prevents potential errors that might occur during program execution. This improves code reliability and maintainability.
- Improves code clarity: Explicit types make code easier to understand, as you can clearly see the expected data type for each variable.

### ClassCastException:
- Despite strong typing, Java allows casting, which is the conversion of a value from one type to another. This can be helpful in certain scenarios, but it's important to use it carefully.
- A ClassCastException occurs when you attempt to cast an object to a type that it's not actually an instance of. For example, trying to cast an Integer object to a String object will result in this exception at runtime.

### Why ClassCastException Exists:
Even though the compiler checks types at compile time, it can't always predict all possible runtime scenarios. Variables might hold objects whose exact types are unknown until runtime.
Casting allows for flexibility in handling objects, but it introduces the risk of runtime errors if the cast is invalid.

#### Example:
```
Object obj = new Integer(5); // Implicit conversion to Object
// This cast will succeed at compile time but fail at runtime with ClassCastException
String str = (String) obj;
```
In this example, the compiler allows the assignment of an Integer object to an Object variable because Object is the ultimate base class in Java. However, the cast to String is invalid because the object is actually an Integer, not a String. This will cause a ClassCastException at runtime.


## Q8. What is the default value of a variable declared as boolean datatype?
The default value for a boolean variable that hasn't been explicitly assigned a value is false.

#### Example:
```
public class BooleanExample {
    public static void main(String[] args) {
        boolean isRunning; // Declared but not assigned
        System.out.println(isRunning); // This will print false
    }
}
```
The above code outputs false. Since isRunning not assigned explicitly, Java automatically sets it to the default value, which is false.

## Q9. How do you do synchronization for a singleton class?
Synchronizing a singleton class in Java ensures that only one instance of the class is ever created, even in multi-threaded environments. Here are two common approaches to achieve this:

### Synchronized getInstance() method:
This approach involves synchronizing the getInstance() method, which is typically responsible for creating and returning the singleton instance.
```
public class Singleton {
	private static volatile Singleton instance;
	private Singleton() {
	} // Private constructor to prevent external instantiation
	public static synchronized Singleton getInstance() {
		if (instance == null) {
			instance = new Singleton();
		}
		return instance;
	}
}
```
- The instance variable is declared volatile to ensure visibility of changes across threads.
- The getInstance() method is marked synchronized. This means only one thread can execute this method at a time.
- Inside the method, a double-check locking mechanism is used for efficiency. It first checks if the instance is null without synchronization. If it's null, then a synchronized block is used to create the instance and assign it to the instance variable. This avoids unnecessary synchronization overhead when the instance already exists.

### Synchronized block within getInstance():
This approach involves using a synchronized block only within the getInstance() method to create the instance, while the overall method might not be synchronized.
```
public class Singleton {
	private static volatile Singleton instance;
	private Singleton() {
	} // Private constructor to prevent external instantiation
	public static Singleton getInstance() {
		if (instance == null) {
			synchronized (Singleton.class) {
				instance = new Singleton();
			}
		}
		return instance;
	}
}
```
- Similar to the previous approach, the instance variable is volatile.
- The getInstance() method is not synchronized itself.
- A synchronized block is used only when the instance is null. This block ensures that only one thread can create the instance at a time.

## Q10. What is the use of pointers?
In Java, there are no pointers in the traditional sense like C or C++. Java uses a different approach to memory management and object access. In programming, pointers are variables that store memory addresses. They act as references to other variables or data locations in memory.

Here's a breakdown of their key uses:

- Direct Memory Access and Manipulation:
  
Pointers allow you to work directly with memory addresses, enabling efficient access and modification of data at those locations. This can be useful for low-level programming, memory management, and performance optimization in certain scenarios.

- Dynamic Memory Allocation:
  
Pointers are crucial for allocating memory dynamically during program execution. You can use functions like malloc (C) or new (C++) to request memory at runtime and store the address in a pointer. This allows for flexible data structures that can grow or shrink as needed.

- Efficient Data Structures:
  
Pointers are fundamental building blocks for many complex data structures like linked lists, trees, and graphs. These structures rely on pointers to connect nodes and navigate the data hierarchy.

- Passing Arguments by Reference:
  
When you pass arguments to functions by reference (using pointers) in some languages, you pass the memory address of the variable instead of its value. This allows the function to directly modify the original data, avoiding unnecessary copying and improving performance.

- Function Pointers:
  
Pointers can also store the memory address of a function. This enables techniques like function callbacks, where you pass a function as an argument to another function, allowing for dynamic execution of code.

## Q11. How to automatically create getters and setters for a class?
Here are two common ways to automatically create getters and setters for a class in Java:

### Using IDE Features:
Most modern IDEs (Integrated Development Environments) like Eclipse, IntelliJ IDEA, and NetBeans offer built-in features to generate getters and setters automatically. Here's a general process:
- Open your class file in the IDE.
- Right-click and navigate to the "Generate" or "Source" menu option.
- Choose the option to "Generate Getters and Setters" (or similar wording depending on your IDE).
- Select the field(s) for which you want to generate getters and setters.
- Customization: Some IDEs allow you to configure options like prefix/suffix for getter/setter names or whether to generate Javadoc comments for the methods.

### Using Lombok (External Library):
Lombok is a popular Java library that provides annotations for generating boilerplate code like getters, setters, equals, hashCode, and toString methods. You can integrate Lombok with your project and use annotations on your class fields:
- Add the Lombok library dependency to your project's build system (e.g., Maven, Gradle).
- Annotate your class fields with @Getter and @Setter for automatic generation of getters and setters, respectively.
```
public class MyClass {
    @Getter @Setter
    private String name;
    
    @Getter @Setter
    private int age;
}
```

## Q12. What is system, out & println?
In Java, System, out, and println work together to provide a way to print messages to the console (standard output). Here's a breakdown of their roles:

- System:
  - This is a final class provided by the Java library that provides access to various system functionalities like standard input, output, error streams, and environment variables.
- out:
  - It's a static field of type PrintStream within the System class.
  - PrintStream is a class that represents an output stream, typically used for console output.
  - By accessing System.out, you're essentially referring to the standard output stream.

- println:
  - It's a method of the PrintStream class (and therefore also available through System.out).
  - This method prints a message to the standard output stream, followed by a newline character.

When you use System.out.println("Hello, world!"), here's what happens:
- You access the standard output stream through System.out.
- You call the println method on the PrintStream object referenced by out.
- The println method prints the string "Hello, world!" to the console and then adds a newline character, effectively moving the cursor to the next line.
