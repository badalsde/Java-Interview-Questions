<h1 align="center">
    OOPS Conceptual Questions
</h1>


## Q1. Explain the OOP concepts with examples. 
Object-Oriented Programming (OOP) is a programming paradigm that revolves around objects. These objects are entities that encapsulate data (properties) and the code that operates on that data (methods or functions). Here are some core OOP concepts with examples:

### Class and Objects:
- Class: A blueprint that defines the properties and methods of similar objects. It acts like a template.
- Object: An instance of a class. It represents a specific entity with its own set of properties and methods.

### Abstraction:
- Abstraction in Java refers to hiding the implementation details of a code and exposing only the necessary information to the user. It provides the ability to simplify complex systems by ignoring irrelevant details and reducing complexity. 
- Java provides many in-built abstractions and few tools to create our own.
- Abstraction in Java can be achieved using the following ways. 
    - Abstract classes
    - Interfaces

### Encapsulation:
- Encapsulation in Java is a fundamental concept in object-oriented programming (OOP). It refers to the wrapping of data and methods that operate on that data within a single unit, which is called a class in Java. Encapsulation is a way of hiding the implementation details of a class from outside access and only exposing a public interface that can be used to interact with the class.
- In Java, encapsulation is achieved by declaring the instance variables of a class as private, which means they can only be accessed within the class. To allow outside access to the instance variables, public methods called getters and setters are defined, which are used to retrieve and modify the values of the instance variables, respectively. 
- By using getters and setters, the class can enforce its own data validation rules and ensure that its internal state remains consistent.

### Inheritance:
- Inheritance in Java is a mechanism in which one class (child class/subclass/derived class) acquires all the properties and behaviors of another class (parent class/superclass/base class). 
- Inheritance is achieved by using the keyword 'extends'.

### Polymorphism:
- The word polymorphism means having many forms. 
- Polymorphism is considered one of the important features of Object-Oriented Programming. 
- Polymorphism allows us to perform a single action in different ways. 
- In other words, polymorphism allows you to define one interface and have multiple implementations.
#### Types of Java Polymorphism:
In Java Polymorphism is mainly divided into two types: 
- Compile-time Polymorphism
- Runtime Polymorphism

#### Compile-Time Polymorphism in Java:
It is also known as static polymorphism. This type of polymorphism is achieved by method overloading. Method overloading occurs within the class. Methods must have the same name and different signatures. The return type of the methods can or cannot be the same, but we just have to change the parameters. The argument list should be different while doing method overloading.

#### Runtime Polymorphism in Java:
It is also known as Dynamic Method Dispatch. It is a process in which a function call to the overridden method is resolved at Runtime. This type of polymorphism is achieved by Method Overriding. Method Overriding is performed in two classes with inheritance relationships. Methods must have the same name and same signature. The return type of the methods must be the same or co-variant. The argument list should be the same in method overriding.

#### Example:

```

//Abstract class
abstract class Shape {
	// Abstract method - subclasses must implement
	public abstract double calculateArea();
	// Method overloading (same name, different parameter lists)
	public void displayInfo(String color) {
		System.out.println("Color: " + color);
	}
	// Overloaded method
	public void displayInfo(String color, double dimension) {
		System.out.println("Color: " + color + ", Dimension: " + dimension);
	}
}
//Inheritance
class Circle extends Shape {
	// Encapsulation and access control
	private double radius;
	public Circle(double radius) {
		this.radius = radius;
	}
	public double getRadius() {
		return this.radius;
	}
	// Implementation for Circle
	@Override
	public double calculateArea() {
		return Math.PI * radius * radius;
	}
	// Method overriding with same name but different parameter
	@Override
	public void displayInfo(String color) {
		// Call parent class displayInfo(String)
		super.displayInfo(color);
		System.out.println("Radius: " + radius);
	}
}
public class Demo {
	public static void main(String[] args) {
		Circle circle = new Circle(5.0);
		System.out.println("Circle Area: " + circle.calculateArea());
		// Calls child class displayInfo(String)
		circle.displayInfo("Blue");
		// Calls overloaded displayInfo(String, double)
		circle.displayInfo("Green", circle.getRadius());
	}
}

```

#### Explanation of code:
- Abstract Class (Shape):
    - Abstract: Cannot create direct objects of Shape.
    - Defines: An abstract method calculateArea() forcing subclasses to implement area calculation (abstraction).
- Inheritance (Circle):
    - Inherits: Circle inherits methods and properties from Shape.
    - Encapsulation: Private radius property protects circle data.
    - mplements: Provides a concrete implementation for calculateArea (circle's formula).
    - Overrides: Overrides displayInfo(String color) to print specific circle information (polymorphism).
- Polymorphism (Demo):
    - Treats: A Circle object can be assigned to a Shape variable (inheritance in action).
    - Calls: Methods are called based on the object's actual type (circle's calculateArea and overridden displayInfo).

- Method Overloading (Shape):
    - Multiple methods: displayInfo(String color) and displayInfo(String color, double dimension).
    - Same name, different parameters: Provides flexibility in how information is displayed.
 
## Q2. Can we have a default implementation in the abstract class?
If we want to have a default implementation of a method in your abstract class, we have to use non-abstract methods. 

In abstract classes, we can declare fields with or without static and final modifiers. 

And concrete methods can be not just public, but also default, protected, or private.

Here is a complete example:

```
abstract class Shape 
 {
	  public abstract double getArea();
	  public void draw() 
	  {
	    System.out.println("Drawing a generic shape");
	  }
	}
	 class Circle extends Shape 
	 {
	  private double radius;
	  public Circle(double radius) 
	  {
	    this.radius = radius;
	  }
	  public double getArea() 
	  {
	    return Math.PI * radius * radius;
	  }
	  public void draw() 
	  {
	    System.out.println("Drawing a circle with radius: " + radius);
	  }
	}
	class Square extends Shape 
	{
	  private double sideLength;
	  public Square(double sideLength) 
	  {
	    this.sideLength = sideLength;
	  }
	  public double getArea() {
	    return sideLength * sideLength;
	  }
	}
	public class Main 
	{
	  public static void main(String[] args) 
	  {
	    Shape circle = new Circle(5);
	    Shape square = new Square(3);
	    circle.draw();
	    square.draw();
	    System.out.println("Circle area: " + circle.getArea());
	    System.out.println("Square area: "  + square.getArea());
	  }
	}

```

#### Output:

Drawing a circle with radius: 5.0<br>
Drawing a generic shape<br>
Circle area: 78.53981633974483<br>
Square area: 9.0<br>

## Q3. What will happen if break statement is not there in Switch statement?
In Java if a break statement is not present at the end of a case block in a switch statement, there is a behavior called fall-through. This means the program execution continues to the next case block, even if the condition for that case wasn't met. It will keep executing until it encounters a break statement or reaches the end of the switch block.

#### Example:

```
public class DayOfWeek {
	public static void main(String[] args) {
		int day = 2; // Change this value to see different outputs
		switch (day) {
		case 1:
			System.out.println("Monday");
		case 2: // No break here!
			System.out.println("Tuesday");
		case 3:
			System.out.println("Wednesday");
			break; // This break is only for case 3
		case 4:
			System.out.println("Thursday");
		default:
			System.out.println("Day not found!");
		}
	}
}

```

#### Explanation:
- The day variable is assigned a value (e.g., 2).
- The switch statement evaluates day.
- Since day is 2, the program enters the case 2 block.
- Crucially, there's no break statement here.
- So, the program execution falls through to the next case (case 3).
- It prints "Tuesday" because day is still 2.
- Then, it encounters the break statement in case 3 and exits the switch block.

Output (for day = 2):

Tuesday<br>
Wednesday

If break was present after case 2:

```
case 2:
System.out.println("Tuesday");
break; // Added break statement
```

Output (for day = 2) with break:

Tuesday<br>
The break statement after case 2 prevents the fall-through behavior, and only the intended case output ("Tuesday") is printed.

## Q4. What are the differences between an Interface and an Abstract class?
| Abstract Class | Interface |
|----------------|-----------|
| An abstract class can contain both abstract and non-abstract methods.	| An interface can contain only abstract methods. From Java 8 onwards, it can contain default and static methods as well. |
| An abstract class can have all four; static, non-static, and final, non-final variables. | Only final and static variables are used. |
| To declare abstract class abstract keywords are used. | The interface can be declared with the interface keyword. |
| It does not support multiple inheritance.	| It supports multiple inheritance. |
| The keyword extends is used to extend an abstract class.	| The keyword implements is used to implement the interface. |
| It has class members like private and protected, etc.	| It has class members public by default.|
| Abstract classes are typically used to provide a base implementation that can be extended by other classes. | Interfaces are typically used to define a contract for behavior that should be implemented by other classes. |


## Q5. What happens when static methods access non-static properties? Why?
Accessing non-static properties from a static method generates a Compilation error. 

As static members are on the stack, when trying to access a non-static property located on a heap, it cannot point to a field without having a reference of the enclosing object.

Here is a complete example:

```

public class StaticAndNonStatic {
	private int value = 10;
	public static void staticMethod() {
		System.out.println(value);/*Compilation Error: Cannot make a static reference to the non-static field value*/
		StaticAndNonStatic obj = new StaticAndNonStatic();
		System.out.println(obj.value); 
	}
	public static void main(String[] args) {
		staticMethod();
	}
}

```

## Q6. Is Java a pure object-oriented language?
Java uses 8 primitive data types and hence is not a pure object-oriented language.

The primitive types are: 
- byte
- sort
- int
- long
- float
- double
- boolean
- char


## Q7. Can a source file contain more than one class declaration?
Yes, a single source file can contain any number of Class declarations but only one of the classes can be declared as public.

Here is a complete example:

```

class HelperClass {  
	public void helperMethod() {
		System.out.println("This is a helper method");
	}
}
public class MultiClass { 
	public static void main(String[] args) {
		HelperClass helper = new HelperClass();
		helper.helperMethod();
	}
}
//Output: This is a helper method

```

## Q8. What are local variables, member variables, and class variables?
Variables declared within a method are "local" variables.

Variables declared within the class, i.e., not within any methods are "member" variables (global variables).

Variables declared within the class, i.e., not within any methods and are defined as "static" are class variables.

Here is a complete example:

```

public class VariableScopes {
		  private String name;
		  public static int count = 10;		
		  public static void main(String[] args) {
		    int age = 30;
		    VariableScopes person1 = new VariableScopes();
		    person1.name = "Ashwini";
		    System.out.println("Age (local): " + age);
		    System.out.println("Name (instance): " + person1.name);
		    System.out.println("Count (static): " + VariableScopes.count);
		  }
	  }

```

Output:

Age (local): 30<br>
Name (instance): Ashwini <br>
Count (static): 10


## Q9. What is the difference between static and non-static variables? 
#### Static Variables: 
- Static variables belong to the class itself, not to any specific object instance.
- There's only one copy of a static variable shared by all objects of the class.
- Static variable is declared using the static keyword.
#### Instance Variables (/Non-static variables):
- Instance variables are part of each individual object instance.
- Each object has its own copy of the instance variable with its own value.
- Instance variables are declared normally within the class but outside of any method.

Example:

```

class Employee {
	public int empId;
	public String empName;
	public static int noOfEmployees = 0;
	public Employee(int empId, String empName) {
		this.empId = empId;
		this.empName = empName;
		Employee.noOfEmployees++;
	}
}
public class Demo {
	public static void main(String[] args) {
		Employee employee1 = new Employee(101, "John");
		Employee employee2 = new Employee(102, "Mary");
		System.out.println(employee1.empId + ":" + employee1.empName + ":" + Employee.noOfEmployees);
		System.out.println(employee2.empId + ":" + employee2.empName + ":" + Employee.noOfEmployees);
	}
}

```

The code gives the output as below:<br>
101:John:2<br>
102:Mary:2<br>

- In the above example, empId and empName are instance variables which belongs to each object created for Employee class and these variables have their own value for each object.
- The static variable noOfEmployees belongs to class which has shared copy to all objects.Since noOfEmployees is static variable, the output reflects 2 for both objects.

### The Key Differences:
|   | Static Variable | Instance variable |
|:-:|-----------------|-------------------|
| **Scope** | Class level | Object level |
| **Number of Copie** | One copy shared by all objects | One copy per object |
| **Declaration**	| static keyword used | No special keyword required |
| **Access** | Accessed using class name | Accessed using object reference |
| **Usage** | Use static variables for values shared by all objects, like counters or utility constants. | Use instance variables for data specific to each object, like a person's name or an item's properties. |

## Q10. Can a class have multiple constructors?
Yes, Java class can have multiple constructors. This is called constructor overloading. It allows to create objects with different ways of specifying their initial state.

Example:

```

class Employee {
	String name;
	int id;
	String department;
	// Constructor with all details (name, id, and department)
	public Employee(String empName, int empId, String dept) {
		name = empName;
		id = empId;
		department = dept;
	}
	// Constructor with name and id (assuming department is assigned later)
	public Employee(String empName, int empId) {
		name = empName;
		id = empId;
	}
	// (Optional) A method to display employee information
	public void displayDetails() {
		System.out.println("Name: " + name);
		System.out.println("ID: " + id);
		System.out.println("Department: " + department);
	}
}
public class Demo {
	public static void main(String[] args) {
		// Create an employee with full details
		Employee emp1 = new Employee("John Doe", 123, "Marketing");
		// Create an employee with name and id (department assignment pending)
		Employee emp2 = new Employee("Jane Smith", 456);
		// Display employee information (if included)
		emp1.displayDetails();
		emp2.displayDetails();
	}
}

```

Employee objects with complete details or just with name and ID are created by constructor overloading. It allows flexibility based on available information at the time of object creation.

## Q11. What is the difference between the Boolean ‘&’ operator and the ‘&&’ operator?
If an expression involving the Boolean ‘&’ operator is evaluated, both operands are evaluated. Then the ‘&’ operator is applied to the operand.

When an expression involving the ‘&&’ operator is evaluated, the first operand is evaluated. If the first operand returns a value of true then the second operand is evaluated. 

The ‘&&’ operator is then applied to the first and second operands. If the first operand evaluates to false, the evaluation of the second operand is skipped.

Here is a complete example:

```

public class AndOperatorComparison {
	  public static void main(String[] args) {
	    boolean isTrue = true;
	    boolean isFalse = false;
	    // Bitwise AND (&)
	    System.out.println("Bitwise AND:");
	    System.out.println(isTrue & isTrue);  // Output: true (1 & 1 = 1)
	    System.out.println(isTrue & isFalse); // Output: false (1 & 0 = 0)
	    System.out.println(isFalse & isFalse); // Output: false (0 & 0 = 0)
	    // Logical AND (&&)
	    System.out.println("\nLogical AND:");
	    System.out.println(isTrue && isTrue);  // Output: true
	    System.out.println(isTrue && isFalse); // Output: false (short-circuited)
	    System.out.println(isFalse && isFalse); // Output: false (evaluated fully)
	  }
	
}

```

## Q12. Why does Java not support operator overloading?
Operator overloading makes the code very difficult to read and maintain. To maintain code simplicity, Java doesn't support operator overloading.


## Q13. What is a data type in Java? What is a reference data type in Java?
A data type is a classification of data items based on their characteristics and the operations that can be performed on them.

The two categories of data types in Java are primitive data types and reference data types.

A primitive data type holds the actual value of the variable.

A reference data type is a data type that refers to an object in memory and can store the memory address of an object.

## Q14. What is casting? Can a Byte object be cast to a double value?
Casting between primitive numeric types and casting between object references. Casting between numeric types is used to convert larger values, such as double values, to smaller values, such as byte values. 

Casting between object references is used to refer to an object by a compatible class, interface, or array type reference.

Yes, a Byte(object type) can be cast to a double(primitive type) value.

Example:

```

public class Tester {
	public static void main(String[] args) {
		Byte b = 100;
		double d = b;  // Implicit widening conversion
		System.out.println(d); // This will print 100.0
	}
}

```

## Q15. What are the types of type casting in Java? Explain.
The two types of type casting in Java are widening and narrowing.
- Widening type casting occurs when a smaller data type is converted to a larger data type, such as converting an int to a long.
    - Widening type casting is performed automatically by Java, without the need for explicit type casting.
- Narrowing type casting occurs when a larger data type is converted to a smaller data type, such as converting a double to an int.
    - Narrowing type casting is performed by explicitly specifying the target data type in parentheses before the variable is converted.

Here is a complete example:

```

public class Tester {
	public static void main(String[] args) {
		int myInt = 9;
	    double myDouble = myInt; // Widening casting: int to double (potential memory loss)
	    System.out.println("myInt value: " + myInt); 
	    System.out.println("myDouble value: " + myDouble); // Prints 9.0
	    
	    double myDouble1 = 9.78;
	    int myInt1 = (int) myDouble; // Narrowing casting: double to int (potential data loss)
	    System.out.println("myDouble value: " + myDouble1); 
	    System.out.println("myInt value: "  + myInt1); // Prints 9 (decimal part truncated)
	}
}

```

## Q16. Why is static used or written before the main method? What happens if we don't write static?
In Java, the main() method is the entry point of the program, which means it is the first method that gets executed when the program starts. To call the main() method directly without creating an object of the class, the method needs to be declared static.

Static methods are often used for utility methods that perform some common functionality that doesn't depend on the state of the object.

If the main() method is not declared as static, then JVM would not be able to call it directly without creating an instance of the class and the program will not run as intended.

If the main() method is not defined as static, you will get a compilation error when you try to compile the Java program.

## Q17. When is it preferable to use a switch over an if-then-else statement and vice versa?
A switch statement is better suited when testing a single variable against many single values or when several values will execute the same code.

An if-then-else statement is preferable when we need to check ranges of values or multiple conditions.

## Q18. What are the different types of loops supported by Java?
Java offers three different types of loops: for, while, and do-while.

A **for loop** provides a way to iterate over a range of values. It's most useful when we know in advance how many times a task is going to be repeated.

A **while loop** can execute a block of statements while a particular condition is true.

A **do-while** is a variation of a while statement in which the evaluation of the Boolean expression is at the bottom of the loop. This guarantees that the code will execute at least once.

## Q19. Why does Java not support multiple inheritance? 
Java does not support multiple inheritance because it can lead to a diamond problem. 

The diamond problem occurs when a class extends two or more classes that have the same method with the same signature. It creates ambiguity for the compiler, which cannot determine which method to use.

To avoid this problem, Java allows classes to extend only one class, but it allows for multiple interfaces to be implemented. Interfaces can have method signatures without providing an implementation. A class can implement multiple interfaces and provide the implementation for each method. This approach provides the benefits of multiple inheritance while avoiding the problems that come with it.

## Q20. What is the impact of declaring a method, a class, and, a variable as final?
Declaring a method, class, or variable as final in Java has different impacts on their behavior and usage, as explained below:

- **Final Method:** A final method in Java cannot be overridden by any subclass. This means that the implementation of the method in the parent class is the final and cannot be changed by any of its subclasses. 

- **Final Class:** A final class in Java cannot be extended by any other class. This means that the final class cannot be used as a superclass for any other class. 

- **Final Variable:** A final variable in Java is a constant and its value cannot be changed once it has been initialized. This means that the final variable can only be assigned a value once, and any attempt to reassign it will result in a compilation error.

Here is a complete example:

```

public class FinalExplanation {
	  // Final variable (constant) - cannot be changed after assignment
	  public static final double PI = 3.14159;
	  // Final method - cannot be overridden by subclasses
	  public final void displayMessage() {
	    System.out.println("This message cannot be overridden in subclasses.");
	  }
	  // Final class - cannot be subclassed
	  public static final class Utility {
	    public static void performTask() {
	      System.out.println("Utility class cannot be extended.");
	    }
	  }
	  public static void main(String[] args) {
	    // PI cannot be reassigned (compile time error)
	    // PI = 3.14;
	    FinalExplanation obj = new FinalExplanation();
	    obj.displayMessage(); // Prints the original message
	    // Subclass cannot extend FinalExplanation (compile time error)
	    // class Subclass extends FinalExplanation { }
	    Utility.performTask(); // Access static method of final class
	  }
}

```

## Q21. Can we override or overload a static method in Java?
Yes, We can overload a static method in Java. the methods must have different parameter types or a different number of parameters to be considered overloaded.

**But,** it is not possible to override a static method. However, a subclass can declare a static method with the same name as the one in its superclass. This is called method hiding, and it allows the subclass to provide its own implementation of the static method. 

Note that this does not override the static method in the superclass, but rather provides a new static method in the subclass with the same name.

Here is a complete example:

```

public class Parent {
	
	public static void print(int value)
	{
		System.out.println("Value is:" + value);
	}
	public static void print(String value)// Declared with different type of parameter
	{
		System.out.println("Value is:" + value);
	}
	public static void print(int value1, String value2)// Declared with different number of parameter
	{
		System.out.println("Values are:" + value1 + " and "+ value2);
	}
	
	public static void print(String value1, int value2)// Declared with different order of parameter
	{
		System.out.println("Values are:" + value1 + " and "+ value2);
	}
}
class Child extends Parent
{
	@Override
	public static void print(int value) /* Compilation Error: The method print(int) of type Child must override or implement a supertype method*/
	{
		System.out.println("Value is:" + value);
	}
}
// If we will remove the @Override there won't be any Compilation Error

 ```

## Q22. What is the difference between Static Polymorphism and Dynamic Polymorphism?  

<p align="center"> OR </p>

## What is the difference between Method Overloading and Method Overriding?

Here are the differences between Static and Dynamic Polymorphism.

| Static Polymorphism | Dynamic Polymorphism |
|---------------------|---------------------|
| It uses compile-time binding | It uses late binding or runtime binding |
| The method invoked is based on the reference type | The method invoked is based on the object type |
| Execution speed is high | Execution speed is low |
| Method Overloading | Method Overriding |


Here are the differences between Method Overloading and Overriding.

| Method Overloading | Method Overriding |
|--------------------|-------------------|
| Method overloading is a way to achieve compile-time polymorphism. | Method overriding is a  way to achieve run-time polymorphism. |
| It increases the readability of the program. | It is used to grant the specific implementation of the method which is already provided by its parent class or superclass. |
| It occurs within the class. | It is performed in two classes with inheritance relationships. |
| Methods must have the same name and different signatures. | Methods must have the same name and same signature. |
| The return type of the methods can or cannot be the same, but we just have to change the parameters. |The return type of the methods must be the same or co-variant. |
| The argument list should be different while doing method overloading. | The argument list should be the same in method overriding. |
| Static binding is being used for overloaded methods. | Dynamic binding is being used for overriding methods. |
| Poor Performance due to compile time polymorphism. | It gives better performance. The reason behind this is that the binding of overridden methods is being done at runtime. |
| Private and final methods can be overloaded. | Private and final methods can’t be overridden. |

#### Example of Method Overloading:

```

public class OverloadingDemo {
	public int add(int a, int b) {
		return a + b;
	}
	public int add(int a, int b, int c) {
		return a + b + c;
	}
	public String add(String s1, String s2) {
		return s1.concat(s2);
	}
	public static void main(String[] args) {
		OverloadingDemo obj = new OverloadingDemo();
		System.out.println(obj.add(10, 20));
		System.out.println(obj.add(100, 200, 300));
		System.out.println(obj.add("Java", "Programming"));
	}
}
/*
Output:
30
600
JavaProgramming
*/

```

#### Example of Method Overriding:

```
class Parent {
	public void greet() {
		System.out.println("Hi");
	}
}
class Child extends Parent {
	@Override
	public void greet() {
		System.out.println("Hello");
	}
}
public class OverridingDemo {
	public static void main(String[] args) {
		Parent parentObj = new Parent();
		Child childObj = new Child();
		parentObj.greet();
		childObj.greet();
	}
}
/*
Output:
Hi
Hello
*/

```

## Q23. What is the use of the ‘super’ keyword?
In Java, the super keyword is used to refer to the parent class or superclass of the current class. Here are some common uses of the super keyword:

To call a superclass constructor: When creating an instance of a subclass, we can use super to call the constructor of the superclass. This is useful when the superclass has some initialization logic that we want to ensure is always executed before the subclass constructor.

To differentiate between superclass and subclass variables and methods: If a subclass has a variable or method with the same name as a variable or method in the superclass, we can use super to refer to the superclass version of the variable or method. 

Example code:

```

public class SubClass extends SuperClass { 
	public SubClass() {
		 super(); // calls the default constructor of the SuperClass
	 } 
	public SubClass(int arg) {
		 super(arg); // calls a parameterized constructor of the SuperClass
	 }
	public void doSomething() { 
		super.doSomething(); // calls the doSomething() method of the SuperClass 
				// additional code for the subclass method 
	}
 }

 ```

## Q24. What is an Abstract Class?
An abstract class is a class prefixed with an abstract keyword.

This class cannot be instantiated on its own and is meant to be subclassed by other classes. It serves as a base or template for other classes to extend and implement its abstract methods.

An abstract class can have both abstract and non-abstract methods. Abstract methods are methods that are declared without implementation and are meant to be implemented by the subclasses. Non-abstract methods, on the other hand, have a complete implementation and can be inherited and used by the subclasses.

The subclass of an abstract class must implement all the abstract methods of the parent abstract class, or else there will be a compilation error.

Here is a complete example:

```

public class AboutAbstractClass {
	public static void main(String[] args) {
		Dog dog = new Dog();
		dog.makeSound(); 
	}
}
abstract class Animal {
	public abstract void makeSound(); 
}
class Dog extends Animal {
	public void makeSound() {
		System.out.println("makeSound Method....");
	}
}
// Output: makeSound Method....

```

## Q25. What is an Interface?
- An interface is a collection of abstract methods that define a contract or a set of behaviors that a class can implement. 
- Interfaces can also contain constants and default methods, which are methods that have a default implementation. A class that implements an interface must - provide an implementation for all the abstract methods in the interface.
- Objects can't be created for the interface and an interface cannot have private or protected members.
- In an interface, all methods are implicitly public and abstract, and variables are implicitly public, static, and final.

Example:

```

interface Drawable {
	public void draw(); 
}
class Circle implements Drawable {
	public void draw() {
		System.out.println("Drawing a circle");
	}
}
public class Main {
	public static void main(String[] args) {
		Drawable d = new Circle();
		d.draw(); 
	}
}
// Output: Drawing a circle

```

## Q26. Can an interface have any method implementation?
An interface cannot have a method implementation. It can only define the method signatures.

However, since Java 8, interfaces can have default methods and static methods with method implementations.

Default Methods: Default methods are methods prefixed with default keywords. These methods have a default implementation in the interface itself. A class that implements this interface can use this default implementation or override it with its own implementation.

Static Methods: Static methods are methods prefixed with static keywords which are defined at the interface level and can be invoked on the interface itself, rather than on a class instance. These methods cannot be overridden by implementing classes.

The introduction of default and static methods in interfaces was done to provide backward compatibility with existing code and to support the functional programming features introduced in Java 8. However, the fundamental concept of an interface is still that it defines a contract for the behavior that must be provided by any implementing class.

Here is a complete example:

```

interface CanFly {
	public void takeOff();
	public default void land() {
		System.out.println("Landing...");
	}
}
class Bird implements CanFly {
	public void takeOff() {
		System.out.println("Taking off...");
	}
}
public class Main {
	public static void main(String[] args) {
		CanFly bird = new Bird();
		bird.takeOff();
		bird.land();
	}
}


```

Output:

Taking off...<br>
Landing...


## Q27. How to use the Predicate Functional Interface?
Predicate is a functional interface that represents a predicate (boolean-valued function) of one argument. It is defined in the java.util.function package and contains test() a functional method.

Consider the below example for Predicate functional interface:

```

import java.util.function.Predicate;  
public class PredicateInterfaceExample {  
    public static void main(String[] args) {  
        Predicate<Integer> pr = a -> (a > 18); // Creating predicate  
        System.out.println(pr.test(10));    // Calling Predicate method    }  }  

```

## Q28. Consider a class with 1 regular (non-static) and 1 static variable. How many instances can be created for the class? Can we create 2 instances? What is the effect in static variables and the effect in non-static variables?
We can create any number of instances of a class having static and non-static variables. But in this case, only one copy of the static variable is created that is shared by all the objects, whereas individual copies of the non-static variables are created for every object.
 
Furthermore, the static variable is accessed by using class-name, whereas the non-static variable is accessed by reference variable name for the corresponding object.

Example:

```

public class DemoClass {
	private int x; //non-static variable
	private static int y; //static variable
	public static void main(String[] args) {
		DemoClass obj1 = new DemoClass();
		DemoClass obj2 = new DemoClass();
		obj1.x = 10; //separate copy of ‘x’ for obj1
		obj2.x = 20; //separate copy of ‘x’ for obj2
		DemoClass.y = 30; //Common ‘y’ variable for obj1 and obj2
		System.out.println(obj1.x + " " + obj2.x + " " + DemoClass.y);
	}
}

```

In the above example, ‘x’ is a non-static variable, and ‘y’ is a static variable in a class ‘DemoClass’. Two instances of a ‘DemoClass’ are created here i.e. obj1 and obj2. Separate copies of ‘x’ is variable are created for obj1 and obj2, whereas a common copy of ‘y’ variable is created for obj1 and obj2.


## Q29. What is encapsulation? Explain from a Java perspective.
**Encapsulation** in Java is a fundamental concept in object-oriented programming (OOP). 

- It refers to the wrapping of data and methods that operate on that data within a single unit, which is called a class in Java.
- Encapsulation is a way of hiding the implementation details of a class from outside access and only exposing a public interface that can be used to interact with the class.
- In Java, encapsulation is achieved by declaring the instance variables of a class as private, which means they can only be accessed within the class. 
- To allow outside access to the instance variables, public methods called getters and setters are defined, which are used to retrieve and modify the values of the instance variables, respectively. 
- By using getters and setters, the class can enforce its own data validation rules and ensure that its internal state remains consistent.
#### Example:

```

class Person {
	private String name;
	private int age;
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public int getAge() {
		return age;
	}
	public void setAge(int age) {
		this.age = age;
	}
}
public class MainClass {
	public static void main(String[] args) {
		// person object created
		Person person = new Person();
		person.setName("John");
		person.setAge(30);
		// Using methods to get the values from the
		// variables
		System.out.println("Name: " + person.getName());
		System.out.println("Age: " + person.getAge());
	}
}

```

Output: <br>
Name: John<br>
Age: 30

## Q30. What is abstraction? 
**Abstraction** in Java refers to hiding the implementation details of a code and exposing only the necessary information to the user. 

It provides the ability to simplify complex systems by ignoring irrelevant details and reducing complexity. Java provides many in-built abstractions and few tools to create our own.
Abstraction in Java can be achieved using the following ways: 
- Abstract classes
- Interfaces
  
| Abstract class | Interface |
|----------------|-----------|
| Abstract classes can have abstract and non-abstract methods. | An interface can have only abstract methods. Since Java 8, it can have default and static methods also. |
| Abstract class doesn't support multiple inheritance. | Interface supports multiple inheritance. |
| Abstract class can have final, non-final, static, and non-static variables. | The interface has only static and final variables. |
| Abstract class can provide the implementation of the interface. | Interface can't provide the implementation of an abstract class. |
| The abstract keyword is used to declare an abstract class. | The interface keyword is used to declare an interface. |
| An abstract class can extend another Java class and implement multiple Java interfaces. | An interface can extend another Java interface only. |
| An abstract class can be extended using keyword "extends". | An interface can be implemented using the keyword "implements". |
| A Java abstract class can have class members like private, protected, etc. | Members of a Java interface are public by default. |

#### Example 1 (Abstract class):

```

abstract class Shape {
	String color;
	abstract double area(); //Abstract method
	@Override
	public abstract String toString();
	// abstract class can have the constructor
	public Shape(String color) {
		this.color = color;
	}
	public String getColor() { // concrete method
		return color;
	}
}
class Circle extends Shape {
	double radius;
	public Circle(String color, double radius) {
		// calling Shape constructor
		super(color);
		this.radius = radius;
	}
	@Override
	double area() {
		return Math.PI * Math.pow(radius, 2);
	}
	@Override
	public String toString() {
		return "Circle color is " + super.getColor() + " and area is : " + area();
	}
}
class Rectangle extends Shape {
	double length;
	double width;
	public Rectangle(String color, double length, double width) {
		// calling Shape constructor
		super(color);
		this.length = length;
		this.width = width;
	}
	@Override
	double area() {
		return length * width;
	}
	@Override
	public String toString() {
		return "Rectangle color is " + super.getColor() + " and area is : " + area();
	}
}
public class MainClass {
	public static void main(String[] args) {
		Shape s1 = new Circle("Red", 2.2);
		Shape s2 = new Rectangle("Yellow", 2, 4);
		System.out.println(s1.toString());
		System.out.println(s2.toString());
	}
}

```

**Output:**<br>
Circle color is Red and area is : 15.205308443374602<br>
Rectangle color is Yellow and area is : 8.0

In the above example, an abstract class ‘Shape’ has an abstract method area() and a concrete method getColor(). The ‘Shape’ class is extended by ‘Circle’ and ‘Rectangle’ classes. These two classes define the area() method as per their own requirements.
 

#### Example 2 (Interface):

```

//Interface declaration: by first user  
interface Drawable {
	void draw();
}
//Implementation: by second user  
class Rectangle implements Drawable {
	@Override
	public void draw() {
		System.out.println("drawing rectangle");
	}
}
class Circle implements Drawable {
	@Override
	public void draw() {
		System.out.println("drawing circle");
	}
}
//Using interface: by third user  
public class MainClass {
	public static void main(String args[]) {
		Drawable d = new Rectangle();
		d.draw();
		d = new Circle();
		d.draw();
	}
}

```

**Output:**<br>
drawing rectangle<br>
drawing circle
 

In the above example, an interface ‘Drawable’ has an abstract method ‘draw()’. It does not have any concrete method. The ‘Drawable’ interface is implemented by two classes i.e. ‘Rectangle’ and ‘Circle’. These two classes define the draw() method as per their own requirements.

## Q31. Explain static keyword.
The ‘static’ keyword may be used with a variable, a method, a block, a class or an import statement.

**1. Static Variable:**
- It is declared outside of all the methods, inside a class, with a 'static' keyword.
- It is accessible anywhere (global access) in the program.
- It is not associated with any individual object, it is class-level variable (common for all objects).
- If it is not initialized by a programmer, then compiler will initialize it to default value.

**2. Static Method:**
- It is not associated with any individual object, it is class-level method (common for all objects).
- Static method cannot directly access non-static variables/methods. It needs an object to access them.
- Static method should be called by using its class-name.

**3. Static block:**
- It is a block of code written by using a keyword ‘static’.
- Static block is executed when the class is loaded.
- Static block is executed only once irrespective of how many instances are created for that class.

**4. Static import:** 

In Java, static import concept is introduced in 1.5 version. With the help of static import, we can access the static members of a class directly without class name or any object. 
e.g. import static java.lang.Math.sqrt;

**5. Static class:**

A class can be made static only if it is a nested class. We cannot declare a top-level class with a static modifier but can declare nested classes as static. Such types of classes are called Nested static classes. Nested static class doesn’t need a reference of Outer class. In this case, a static class cannot access non-static members of the Outer class.

#### Example1: Static variable, static class, static block, static import

```

import static java.lang.Math.sqrt; //Example of static import
class StaticDemo {
	static int x = 10; // static variable
	int y = 20;
	static void test() {// static method
		int z = x; // static method can access static variable 'x'
		// z=y;//Error: static method cannot access non-static variable 'y'
		System.out.println("Static method is executed");
	}
	static // Static block
	{
		System.out.println("Static Block is executed");
	}
}
public class MainClass {
	public static void main(String[] args) throws CloneNotSupportedException {
		StaticDemo ob = new StaticDemo();
		System.out.println("Value of x = " + StaticDemo.x); // proper way of accessing static member
		StaticDemo.test(); // proper way of accessing static member
		// System.out.println(Math.sqrt(25)); //without static import
		System.out.println(sqrt(25)); // with static import
	}
}

```

**Output:**<br>
Static Block is executed<br>
Value of x = 10<br>
Static method is executed<br>
5.0<br>
 

#### Example2: Static class

```

public class MainClass {
	private static String str = "Java";
	// Static class
	static class MyNestedClass {
		// non-static method
		public void disp() {
			System.out.println(str);
		}
	}
	public static void main(String args[]) {
		MainClass.MyNestedClass obj = new MainClass.MyNestedClass();
		obj.disp();
	}
}

```

**Output:**<br>
Java

## Q33. Define Constructors in Java with examples. 
A constructor is a special type of method in Java that is invoked automatically whenever a new object of a class is created. 
It's responsible for initializing the object's state (instance variables) by assigning them appropriate values.
Constructors share the same name as the class they belong to, but unlike methods, they don't have a return type (not even void).

### Types of Constructors:

- #### Default Constructor:
    If you don't explicitly define a constructor in your class, Java provides a default constructor with an empty body (public ClassName()).
    This default constructor initializes instance variables to their default values.
- #### Parameterized Constructor:
    You can define constructors with parameters to provide initial values for the object's instance variables during creation.
- #### Constructor Overloading:
    A class can have multiple constructors with different parameter lists. This allows you to create objects in various ways, providing different sets of initial values.
Overloaded constructors are distinguished by the number, order, and/or types of their parameters.

#### Example:

```

class Car {
    String brand;
    int modelYear;
    // Default constructor (no arguments)
    public Car() {
        brand = "Unknown";
        modelYear = 0;
    }
    // Parameterized constructor (accepts brand and modelYear)
    public Car(String brand, int modelYear) {
        this.brand = brand;  // Use 'this' to refer to the current object
        this.modelYear = modelYear;
    }
    public void displayDetails() {
        System.out.println("Brand: " + brand);
        System.out.println("Model Year: " + modelYear);
    }
}
public class Main {
    public static void main(String[] args) {
        // Creating an object using the default constructor
        Car car1 = new Car();
        car1.displayDetails();  // Output: Brand: Unknown, Model Year: 0
        // Creating an object using the parameterized constructor
        Car car2 = new Car("Toyota", 2023);
        car2.displayDetails();  // Output: Brand: Toyota, Model Year: 2023
    }
}

```

**Applications of Constructors:**

Object Initialization: Constructors ensure that objects are created in a well-defined state by providing initial values for their instance variables.


## Q34. What are wrapper classes?
A Wrapper class in Java is a class whose object wraps or contains primitive data types. When we create an object of a wrapper class, it contains a field, and in this field, we can store a value of the corresponding primitive type. In other words, we can wrap a primitive value into a wrapper class object.

Java automatically converts between primitive data types (like int, double) and their corresponding wrapper classes (like Integer, Double) in a process called autoboxing and unboxing.

**Autoboxing (Primitive to Wrapper)**

Here's an example of autoboxing:

```

int num = 10;
Integer numObj = num; // Autoboxing: int to Integer

```

In this code, the primitive value 10 (an int) is automatically converted to an Integer object (numObj) during assignment.


**Unboxing (Wrapper to Primitive)**

Unboxing is the conversion from a wrapper class object back to its primitive type. The compiler performs unboxing implicitly when needed:

```

Integer numObj = 20;
int num = numObj; // Unboxing: Integer to int (happens automatically)
if (num > 15) {
  System.out.println("Number is greater than 15");
}

```

## Q35. Explain the differences between protected and default access specifiers?
- The key differences between protected and default access specifiers in Java lie in their scope and visibility.
- Members (methods, variables) declared with default access are only accessible within the same package. 
- Members declared with protected are accessible within the same package and in subclasses in different packages.

**Example:**

```

package com.infy.package1;
public class Employee {
	int defaultVariable = 20;
	protected int protectedVariable = 30;
	public static void main(String[] args) {
		Employee t = new Employee();
		System.out.println(t.defaultVariable);
		System.out.println(t.protectedVariable);
	}
}
package com.infy.package1;
public class Demo {
	public static void main(String[] args) {
		Employee employee = new Employee();
		System.out.println(employee.defaultVariable);
		System.out.println(employee.protectedVariable);
	}
}
package com.infy.package2;
import com.infy.package1.Employee;
public class PermanentEmployee extends Employee {
	public static void main(String[] args) {
		PermanentEmployee p = new PermanentEmployee();
		System.out.println(p.protectedVariable);
		System.out.println(p.defaultVariable); //line1
	}
}

```

#### Explanation:
- In the above example, there are three classes are defined.
- Employee class and Demo class are defined in the com.infy.package1 PermanentEmployee class in com.infy.package2 extends Employee class in com.infy.package1.
- Employee class have protected and default variables. Since Demo class is in same package, both variables can be accessed by the main() method in Demo class without any error.
- But, main() method of PermanentEmployee  class generates the error in Line1 due to the invisibility of default access modifier.


## Q36. Can a Constructor return a value?
- **No,** constructors in Java cannot directly return a value like a method does. Their primary purpose is to initialize the object's state, not to provide a return value.
- Constructors are invoked during object creation using the new keyword. The new operator itself is responsible for allocating memory and returning a reference to the newly created object.
- The main concern of a constructor is to set up the object's initial state by assigning values to its properties. Returning a value would shift the focus away from this core responsibility.

**Example:**

```

public class Trainee {
	String name;
	public void Trainee(String name) { // line1
		this.name = name;
		System.out.println(this.name);
	}
	public static void main(String[] args) {
		Trainee trainee = new Trainee("John"); // line2
	}
}

```

Since the void return type is given in line1, it will be considered as a method of Trainee class and the above code gives compilation error in line2 as Undefined Constructor. 


## Q37. Can an interface extend another interface?
- **Yes,** in Java, an interface can extend another interface. This allows you to create more specialized interfaces that inherit methods and functionalities from existing ones.
- An interface can extend one or more interfaces using the extends keyword in its declaration. 
- The subclass interface (child interface) inherits all abstract methods and constants from the parent interface(s).
- It can then add its own abstract methods and constants, further defining the contract for implementing classes.
- Unlike class inheritance (where a class can only extend one class), an interface can extend multiple interfaces (multiple inheritance), forming a richer contract for implementing classes.

##### Example:

```

interface Payment {
	void processPayment(double amount);
}
interface SecurePayment extends Payment {
	void verifySecurityCode(String code);
}
public class CreditCardPayment implements SecurePayment {
	@Override
	public void processPayment(double amount) {
		System.out.println("Processing credit card payment of $" + amount);
	}
	@Override
	public void verifySecurityCode(String code) {
		System.out.println("Verifying security code...");
	}
}

```

- The Payment interface defines an abstract method for processing a payment.
- The SecurePayment interface extends Payment and adds a method for security code verification.
- The CreditCardPayment class implements the SecurePayment interface.
- CreditCardPayment inherits the processPayment method and implements the verifySecurityCode method specific to credit card payments.


## Q38. Can we have a private constructor in Java?
- **Yes,** A class can have a private constructor in Java. A private constructor restricts the creation of objects of that class from outside the class.
- By making the constructor private, objects are created only through methods within the class.
- They are useful for singletons, utility classes, and situations where you want to manage object creation within the class itself.
- Private constructors offer a way to restrict object creation and enforce controlled initialization.
- Some utility classes might just contain static methods and don't require object creation. A private constructor enforces this by preventing accidental object instantiation.

##### Example:

```

public class MathUtil {
	private MathUtil() { // Private constructor to prevent object creation
	}
	public static int add(int x, int y) {
		return x + y;
	}
	public static double divide(double x, double y) {
		return x / y;
	}
	// (and other static utility methods)
}

```

- The MathUtil class has a private constructor. This prevents anyone from creating objects of this class using new MathUtil().
- The class contains static methods like add and divide that perform mathematical operations.
- Since the constructor is private, users can only access these functionalities through the static methods, promoting controlled usage.


## Q39. What is an Enum?
- An enum, short for enumeration, is a special data type in Java that defines a collection of named constants. 
- Enums in Java inherently have private constructors. 
- The enum constructor is implicitly called by the Java compiler at the time of enum declaration. The enum constructor can’t be called directly using new.
- When an enum constant (e.g., PizzaSize.SMALL) are used, the corresponding instance is created internally during enum initialization.

### Reasons for Private Constructors:
- Fixed Set of Values: Enums represent a collection of constant values. A public constructor would allow creating instances outside the enum, potentially introducing invalid or unexpected values.
- Singleton-like Behavior: Each enum constant acts like a singleton object, accessible by its name. Private constructors prevent creating multiple instances for the same constant.

### Methods in Enum:
- Two important methods supported by enum are:
    - values() Method:
        - Returns an array containing all the enum constants in the order they were declared.
        - Useful for iterating through all enum values or creating an array of them.
    - ordinal() Method:
        - Returns the position (index) of an enum constant within its declaration order, starting from 0.
        - Useful for comparing enum constants or using their positions in logic.

#### Example:

```

enum PizzaSize {
	SMALL, MEDIUM, LARGE, EXTRALARGE;
}
public class Pizza {
	private PizzaSize size;
	public Pizza(PizzaSize size) {
		super();
		this.size = size;
	}
	public double calculatePrice() {
		double basePrice = 0;
		switch (size) {
		case SMALL:
			basePrice = 100;
			break;
		case MEDIUM:
			basePrice = 150;
			break;
		case LARGE:
			basePrice = 250;
			break;
		case EXTRALARGE:
			basePrice = 400;
			break;
		}
		return basePrice;
	}
	public static void main(String[] args) {
		PizzaSize[] sizes = PizzaSize.values();
		System.out.println("The Available Pizza Sizes are:");
		for (PizzaSize size : sizes) {
			System.out.println(size.ordinal() + ":" + size);
		}
		Pizza myPizza = new Pizza(PizzaSize.MEDIUM);
		System.out
				.println("You ordered a " + myPizza.size + " pizza. Cost for the pizza is " + myPizza.calculatePrice());
	}
}

```

- This enum defines constants for different pizza sizes (SMALL, MEDIUM, LARGE, EXTRALARGE).
- The size attribute of pizza class uses the enum and based on the size the price is calculated.


## Q40. What is the use of inner classes in Java?
- Inner classes in Java are classes defined within another class.
- Inner classes help to group related classes together, improving code organization.
- Inner classes can access members (variables and methods) of the outer class, even if they are private. This allows for a tighter relationship and data sharing between the classes.
- Inner classes can be used to create event listeners or callback methods specific to the outer class's context.
- Inner classes are used to define helper or utility classes that are only used within the outer class. This helps keep the outer class's public API clean and hides implementation details.

#### Example:

```

class Manager {
	private String name;
	public Manager(String name) {
		this.name = name;
	}
	public String getName() {
		return name;
	}
	class Employee { // Inner class - Employee for this Manager
		private String name;
		public Employee(String name) {
			this.name = name;
		}
		public String getName() {
			return name;
		}
	}
	public Employee hireEmployee(String name) {
		return new Employee(name); // Create and return an Employee object
	}
}
public class Company {
	public static void main(String[] args) {
		Manager manager = new Manager("Peter");
		Manager.Employee employee = manager.hireEmployee("Martin");
		System.out.println("Manager: " + manager.getName());
		System.out.println("Employee: " + employee.getName() + " (reports to " + manager.getName() + ")");
	}
}

```

- In the above code the classes Company (main), Manager, and Employee are defined  
- Manager has a name and a method to get it. 
- Since Employee class is defined as an inner class within Manager class. Object of an Employee is tightly coupled to a specific Manager object. 
- Manager class has a hireEmployee method that creates a new Employee object with the provided name. 
- The main method creates a Manager and uses its hireEmployee method to create an Employee. It then prints information about both.
- The inner class Employee is accessible only within the Manager class. The reference of Manager Class is required to create object in main methos of Company class.


## Q41. What is a marker interface?
A marker interface in Java is an interface that doesn't contain any methods, fields, or constants. It acts like a flag or tag to convey some special characteristic or capability of a class that implements it.

Here's a concise explanation:

- **Empty Interface:** No methods or definitions inside.
- **Purpose:** Adds metadata about a class at runtime.
- **Example:** Serializable interface is a marker interface that indicates a class can be serialized for object persistence.


## Q42. In Java everything is pass by value whether primitives or objects. True or False? What will happen when we pass class object as method parameter?  
**True,** in Java, when you pass arguments (parameters) to methods, it's a pass-by-value mechanism. This means that a copy of the argument's value is created and passed to the method. Any modifications made within the method affect only the copy, not the original variable in the calling code.

#### Primitive Data Types
- Primitive data types (like int, double, char) hold their actual values directly in the variable.
- When you pass a primitive variable to a method, a copy of its value is passed.
- Changes inside the method won't affect the original variable.

#### Object References
- Objects (instances of classes) reside in the heap memory.
- Variables of object types store references (memory addresses) that point to the actual object in the heap.
- When you pass an object reference to a method, a copy of the reference is passed.
- Both the original reference and the method's reference point to the same object.
- Modifications to the object's state (member variables) within the method will be reflected in the original object since they both refer to the same instance.

##### Example:

```

public class Demo {
	public static void changePrimitive(int x) {
		x = 10; // Modifies the copy of x, not the original
	}
	public static void changeObject(Person p) {
		p.name = "Alice"; // Modifies the object's state (member variable)
	}
	public static void main(String[] args) {
		int num = 5;
		Person person = new Person("Bob");
		changePrimitive(num); // num remains 5
		System.out.println(num); // Output: 5
		changeObject(person); // person.name is now "Alice"
		System.out.println(person.name); // Output: Alice
	}
}
class Person {
	String name;
	public Person(String name) {
		this.name = name;
	}
}

```


## Q43.If class A has a static variable, can class B change its value? If class B changes class A’s static variable, what will happen to it?
**Yes,** class B can change the value of a static variable in class A, provided the access specifier rules are followed. Static variables belong to the class itself, not to any specific instance of the class. This means there's only one copy of the static variable in memory, shared by all instances of the class and accessible using the class name (e.g., ClassName.staticVariable).

Here's how it works:

- **Class A with Static Variable:** Class A defines a static variable, for example:

```
public class A {
   public static int staticVar = 0;
}

```

- **Class B Accessing and Modifying:** Class B can access and modify the static variable of class A using the class name:

```

public class B {
   public static void main(String[] args) {
       A.staticVar = 10; // Modifying the static variable of class A
       System.out.println(A.staticVar); // Output: 10
   }
}

```
In this scenario, when A.staticVar is assigned 10 in class B's main method, the single copy of the static variable is updated, and any subsequent access to A.staticVar (from either class A or B) will reflect the new value (10).


## Q44. What is cloning in Java? How does cloning work with Singleton?
In Java, cloning refers to creating a copy of an object. This copy object is separate from the original and has its own memory space. There are two main points to consider about cloning in Java:

**The clone() method:** The clone() method is inherited from the Object class and can be used to create a copy of an object. However, for this to work, the class itself needs to implement the Cloneable interface. Implementing Cloneable simply signifies that the class's objects can be cloned.

**Shallow vs. Deep Copy:** By default, the clone() method in Java performs a shallow copy. This means that the fields of the object are copied, but if any of those fields are references to other objects, those references are simply copied as well. Both the original and the clone will point to the same objects in memory for those referenced fields.

Cloning and singletons in Java have a fundamental conflict.

#### Singleton Design Pattern:
The singleton design pattern ensures that there's only one instance of a class. This is achieved by:

- Making the class constructor private to prevent direct object creation.
- Providing a static method to access and potentially create the single instance.

#### Cloning and the Issue:
- The clone() method, by default, performs a shallow copy. This means if a singleton class implements Cloneable and you call clone() on its instance, it would create a new object with the same field values (including the reference to the single instance itself).
- This breaks the core principle of the singleton pattern, resulting in two objects having access to the same internal state, potentially causing unexpected behavior.

```

class Singleton implements Cloneable {
	private static Singleton instance;
	private Singleton() {
	} // Private constructor
	public static Singleton getInstance() {
		if (instance == null) {
			instance = new Singleton();
		}
		return instance;
	}
	@Override
	public Object clone() throws CloneNotSupportedException {
		return super.clone();
	}
}
public class Demo {
	public static void main(String[] args) throws CloneNotSupportedException {
		Singleton instance1 = Singleton.getInstance();
		Singleton instance2 = (Singleton) instance1.clone(); // Attempt to clone
		// Now you have two instances of Singleton, breaking the pattern
	}
}

```

#### There are ways to address this:
- Not Implementing Cloneable:

    The simplest approach is to not implement the Cloneable interface in your singleton class. Since the clone() method is inherited from Object, attempting to clone a non-Cloneable object throws a CloneNotSupportedException.

- Overriding clone() method:

    You can override the clone() method in your singleton class to throw a CloneNotSupportedException explicitly, preventing any attempt to clone the object.


## Q45. Difference between HashMap and ConcurrentHashMap.
|   | HashMap | ConcurrentHashMap |
|---|---------|-------------------|
| **Synchronization** | Non-synchronized | Synchronized |
| **Thread Safety** | Not thread-safe | Thread-safe |
| **Performance** | Faster | Slower |
| **Key Constraints** | Allows null keys | Does not allow null keys |
| **Value Constraints** | Allows null values | Does not allow null values |
| **Iteration** | Concurrent modification throws a ConcurrentModificationException. | Allows concurrent modification without exceptions. |
| **Common Use Cases** | Single-threaded or controlled access	Multi-threaded applications |


## Q46. Differentiate between Autoboxing and Unboxing.
|  | Autoboxing | Unboxing |
|--|------------|----------|
| **Definition** | Automatic conversion of a primitive value into an object of the corresponding wrapper class. | Automatic conversion of an object of a wrapper type to its corresponding primitive value. |
| **Example** |	Integer i = 5; <br>  OR <br>  Integer i = Integer.valueOf(5); | Integer i = 10; <br> int num = i; |
| **Using null** | Integer i = null; // No issue | Integer i = null; int j = i; <br> Compiles, but throws NullPointerException. |
| **Purpose** | Simplify code by hiding explicit conversions | Extract the primitive value from the wrapper |
| **Common Use Case** | When assigning primitive values to wrapper variables, passing primitives to methods expecting wrappers | When using wrapper object methods that return primitive values, passing wrappers to methods expecting primitives |

- Autoboxing and unboxing lets developers write cleaner code, making it easier to read.
- Unboxing involves a potential for runtime errors if the wrapper object is null or doesn't hold the expected primitive type. It's recommended to check for null before unboxing.
- The technique lets us use primitive types and Wrapper class objects interchangeably and we do not need to perform any typecasting explicitly.


## Q47. What are Call by value and Call by reference? Does Java support call by reference and why?
Call by value and Call by reference concepts refer to how arguments are passed to functions in programming languages.

**Call by Value:** When a function is called, a copy of the argument's value is passed to the function. Any changes made within the function only affect the copy, not the original variable.

**Call by Reference:** The function receives a reference (memory address) of the original argument. When changes are made within the function, they directly modify the original variable.

#### Java's Approach: Call by Value with Reference Semantics
Java primarily uses call by value. However, there's a twist due to how reference types (objects, arrays, strings) are handled in memory:

Primitive types (int, double, etc.) are stored in the function's local stack frame. When passed to a function, their values are copied. Changes within the function don't affect the original variables.

Reference types store memory addresses that point to the actual objects in the heap. When passed to a function, a copy of the reference is passed, not the object itself. However, the copy still points to the same object in memory. Modifications within the function affect the original object because both the original variable and the function's argument reference the same object.

##### Example:

```

public class Demo {
	public static void changePrimitive(int x) { // Call by value
		x = 100; // Modifies the copy, not the original
	}
	public static void changeObject(Person p) { // Call by value with reference semantics
		p.name = "Alice"; // Modifies the original object
	}
	public static void main(String[] args) {
		int num = 5;
		changePrimitive(num);
		System.out.println(num); // Output: 5 (original value remains unchanged)
		Person person = new Person("Bob");
		changeObject(person);
		System.out.println(person.name); // Output: Alice (original object modified)
	}
}
class Person {
	public String name;
	public Person(String name) {
		this.name = name;
	}
}

```

**Java doesn't support call by reference in the strict sense.** It uses call by value for everything. However, for objects (reference types), call by value with reference semantics applies. This means a copy of the object reference is passed, but it still points to the same object, so changes within functions can affect the original object.
