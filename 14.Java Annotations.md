<h1 align="center">
  Java Annotations Conceptual Questions
</h1>

## Q1. What are Annotations? What are their typical use cases?
Annotations are metadata bound to elements of the source code of a program and have no effect on the operation of the code they operate.

Their typical uses cases are:

- **Information for the compiler** – with annotations, the compiler can detect errors or suppress warnings
- **Compile-time and deployment**- time processing – software tools can process annotations and generate code, configuration files, etc.
- **Runtime processing** – annotations can be examined at runtime to customize the behavior of a program


## Q2. Describe some useful Annotations from the Java standard library.
There are several annotations in the java.lang and java.lang.annotation packages, the more common ones include:

- **@Override** – marks that a method is meant to override an element declared in a superclass. If it fails to override the method correctly, the compiler will issue an error
- **@Deprecated** – indicates that element is deprecated and should not be used. The compiler will issue a warning if the program uses a method, class, or field marked with this annotation
- **@SuppressWarnings** – tells the compiler to suppress specific warnings. Most commonly used when interfacing with legacy code written before generics appeared
- **@FunctionalInterface** – introduced in Java 8, indicates that the type declaration is a functional interface and, whose implementation can be provided using a Lambda Expression


## Q3. How can you create an Annotation in Java?
Annotations are a form of an interface where the keyword interface is preceded by @, and whose body contains annotation-type element declarations that look very similar to methods:

```

public @interface SimpleAnnotation { 
	String value(); int[] types(); 
}

```

After the annotation is defined, yon can start using it through your code:

```

@SimpleAnnotation(value = "an element", types = 1)
public class Element { 
	@SimpleAnnotation(value = "an attribute", types = { 1, 2 }) 
	public Element nextElement; }

```

Here is a complete Example:

```

public class AuthorAnnotationExample {
	  @interface Author {
	    String name() default "";
	    int year() default 2024; 
	  }
	  public static void main(String[] args) {
	    @Author(name = "Bard", year = 2024)	    
	  class AnnotatedClass {
	      public void someMethod() {
	        System.out.println("This method is part of a class annotated with Author information.");
	      }
	    }
	    AnnotatedClass obj = new AnnotatedClass();
	    obj.someMethod();
	  }
	}

```

## Q4. What Object types can be returned from an Annotation method declaration?
The return type must be a primitive, String, Class, Enum, or an array of one of the previous types. Otherwise, the compiler will throw an error.


## Q5. Is there any way to limit the elements to which an Annotation can be applied?
Yes, the @Target annotation can be used for this purpose. If we try to use an annotation in a context where it is not applicable, the compiler will issue an error.

Here's an example to limit the usage of the @SimpleAnnotation annotation to field declarations only:

```

@Target(ElementType.FIELD) public @interface SimpleAnnotation { 
	// ... }

```

We can pass multiple constants if we want to make it applicable in more contexts:

```

@Target({ ElementType.FIELD, ElementType.METHOD, ElementType.PACKAGE })

```
