<h1 align="center"> 
    Java Architecture Conceptual Questions 
</h1>

## Q1. Explain the HotSpot JVM (Java Virtual Machine) Architecture in short
JVM (Java Virtual Machine) consists of **Class Loader Subsystem, Runtime Data Areas and Execution Engine**. 
Let’s discuss each of them.
1. Class Loader Subsystem of JVM
   - Class Loader is used to load class files.
2. Runtime Data Areas of JVM
   - Method Area > Method area stores data for each and every class like fields, constant pool, method’s data and information
   - Heap > Heap is place where all objects are stored in JVM
   - Java Threads (Java thread Stacks) >Whenever new method is called new stack frame is created and it is pushed on top of that thread's stack
   - Program counter registers (PC Registers) > the address of instructions currently and next address being executed.
   - Native internal Threads (Native thread stack) >Native internal threads area contains all the information related to native platform.
3. Execution Engine of JVM
   - JIT(Just In Time) compiler > JIT compiler compiles bytecodes to machine code at run time and improves the performance of Java applications.3.2) Garbage Collector - Garbage Collector Garbage collection is the process by which JVM clears objects (unused objects) from heap to reclaim heap space.

4. Native method libraries of JVM > Native method interface is an interface that connects JVM with the native method libraries for executing native methods.

## Q2. What is the role of JVM in making Java a platform- independent language?
  - Once source code (i.e. .java file) is compiled on one platform, bytecode is formed. This bytecode can be executed (interpreted) on any other platform running a JVM. 
  - Every platform may have different JVM implementation. 
  - For example, JVM for windows platform is different from JVM for Linux platform.

## Q3. What is the difference between the Java Development Kit (JDK) and the Java Runtime Environment (JRE)?
- **JDK:** The JDK is a development environment for building Java applications. It includes the JRE, as well as development tools such as the Java compiler, debugger, and other tools required for developing Java applications. It also includes libraries, documentation, and sample code. The JDK is required for developing Java applications.
- **JRE:** The JRE is a runtime environment for running Java applications. It includes the Java Virtual Machine (JVM), which is required for running Java bytecode. It also includes libraries and other components required for running Java applications. The JRE is not required for developing Java applications, but it is required for running them.

## Q4. What is the difference between JRE and JVM?
**JRE** stands for Java Runtime Environment, which is a set of libraries, classes, and other resources that are necessary for running Java applications.
- It includes the JVM, as well as other necessary components such as class libraries, support files, and configuration files.
- JRE is a software package that provides the minimum set of tools required for running Java applications on a specific platform.


**JVM** (Java Virtual Machine) is the heart of Java programming language. 
- When we execute a Java program, JVM is responsible for converting the byte code to the machine-specific code.
- JVM is also platform-dependent and provides core Java functions such as memory management, garbage collection, security, etc. 
- JVM is called virtual because it provides an interface that does not depend on the underlying operating system and machine hardware.
- JVM is an abstract machine that provides a runtime environment for Java programs, while JRE is a software package that includes the JVM, as well as other necessary components for running Java applications. 
- The JVM is an essential part of the JRE, but the JRE provides additional tools and resources that are needed for running Java applications.

## Q5. What is Hot-spot compiler/JIT?
- Just-in-time (JIT) compiler, the Java JIT compiler compiles Java byte code to native executable code during the runtime of your program. 
- This increases the runtime of your program significantly. 
- The JIT compiler uses runtime information to identify parts of your application that are runtime intensive. 
- These so-called "hot spots" are then translated into native code. This is the reason why the JIT compiler is also called a "Hot-spot" compiler.
- JIT stores the original bytecode and the native code in memory because JIT can also decide that certain compilation steps must be revised.

## Q6. Explain Java ClassLoader and the types of Java ClassLoaders.
In Java, a classloader is a crucial component of the Java Runtime Environment (JRE) that's responsible for dynamically loading Java classes into the Java Virtual Machine (JVM) at runtime. It's responsible for finding, loading, and making classes available to the JVM when they're needed by your program.

Unlike some programming languages that load all classes upfront, Java's classloader employs a demand-loading approach. Classes are loaded only when they're first referenced or used by the program, improving memory efficiency and startup time.

#### Types of Classloaders:
* Bootstrap Classloader (Primordial Classloader):
  - Written in native code and loads core Java classes from the JRE's libraries (like rt.jar).
  - It's the root of the hierarchy and cannot be directly accessed from Java code.
* Extension Classloader:
  - Loads classes from the jre/lib/ext directory or other directories specified by the java.ext.dirs system property.
  - Often used for optional extensions or system-wide libraries that need to be accessible by all applications.
* System Classloader (Application Classloader):
  - The workhorse for most applications.
  - Loads classes from the system's classpath (usually set by the CLASSPATH environment variable or command-line arguments).
  - This is where your application code and standard libraries reside.
* Custom Classloaders:
  - You can create custom classloaders to implement specific loading behavior or security restrictions.
  - Useful for scenarios like loading classes from databases or remote servers.
#### Hierarchy:
- Classloaders follow a parent-child hierarchy. When a class needs to be loaded, the request is first delegated to the current thread's context classloader (usually the system classloader for your application).
- If the classloader cannot find the class in its designated search locations, it delegates the search request to its parent classloader.
- This delegation continues up the hierarchy until a classloader successfully finds and loads the class, or an exception is thrown if the class cannot be located anywhere.
- This hierarchy ensures that core Java classes are always loaded first, followed by extensions and finally your application-specific classes. It prevents conflicts between classes with the same name from different sources.

## Q7. What is the difference between Path and Classpath?
Path and Classpath are operating system-level environment variables. The **path** is used to define where the system can find the executables (.exe) files and the **classpath** is used to specify the location of .class files.

## Q8. What happens to the JVM if the Thread Stack reaches to the maximum level?
When the thread stack in a Java Virtual Machine (JVM) reaches its maximum level, one of the major issues that can occur is a StackOverflowError. 

#### Stack Overflow Exception:
If a thread’s call depth becomes very deep (for example, due to recursive method calls), it can lead to a stack overflow. This occurs when the thread stack reaches its maximum allowable limit. When this happens, the JVM throws a java.lang.StackOverflowError exception, indicating that the thread has exhausted its stack space.

#### Example:
```
public class StackOverflowExample {
	public static void recursiveMethod(int count) {
		if (count > 0) {
			recursiveMethod(count - 1); // Recursive call without a base case
		} else {
			System.out.println("Base case reached!");
		}
	}
	public static void main(String[] args) {
		recursiveMethod(10000); // Large number of recursive calls
	}
}
```
#### Explanation:
- The recursiveMethod function calls itself continuously until the count reaches zero.
- With each call, a new frame is pushed onto the thread's stack, storing local variables and method return addresses.
- In this example, there's no base case to stop the recursion, leading to a large number of method calls and stack frames.
- As the recursion continues, the stack grows, eventually reaching its limit.
- This throws a StackOverflowError exception, terminating the program abnormally.

## Q9. I open a text file, write a properly formatted byte code and save it as .class file. Will it get executed?
**No,** simply writing properly formatted bytecode to a .class file and saving it won't get it executed. Here's why:
- Bytecode Needs an Interpreter: It's not machine code that a CPU can directly understand and execute.
- class File Structure: A .class file isn't just raw bytecode. It has a specific structure defined by the Java Virtual Machine specification. While you could potentially write the bytecode portion yourself, creating a valid .class file requires understanding this structure.
- Loading and Execution: To run the bytecode, you need the JVM. Just having the .class file on its own isn't enough.

## Q10. Where are the JNDI names configured in Java applications? 
JNDI names (Java Naming and Directory Interface names) in Java applications are configured in various locations depending on the deployment environment and the specific technology used for JNDI access. Here are the common scenarios:

- Deployment Descriptors:

For web applications (WAR files) deployed on application servers like Tomcat, JBoss, or WebLogic, JNDI names are often configured within deployment descriptors. These are XML files like web.xml or server-specific configuration files that provide deployment information to the application server.

The actual location and format of these configuration elements might vary depending on the specific application server and its deployment descriptor format.

- Application Code (Annotations):
  
In some Java frameworks like Spring, EJB (Enterprise Java Beans), or CDI (Context Dependency Injection), you can define JNDI names using annotations directly within your application code.

- Server Configuration:
  
In some cases, JNDI names might be configured directly within the application server's administration console or configuration files. This is typically used for server-wide resources or global configurations accessible by all applications deployed on the server.

- Environment Variables:
  
Less commonly, JNDI names might be retrieved from environment variables set at runtime. This approach offers flexibility but can be less manageable for complex deployments.
