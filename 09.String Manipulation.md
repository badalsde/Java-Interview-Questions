<h1 align="center">
  String Manipulation Conceptual Questions
</h1>


## Q1. What are the differences between String and StringBuffer?
| String | StringBuffer |
|--------|--------------|
| The String class is immutable. | The StringBuffer class is mutable. |
| String is slow and consumes more memory when we concatenate too many strings because every time it creates a new instance. | StringBuffer is fast and consumes less memory when we concatenate. |
| String class overrides the equals() method of Object class. So you can compare the contents of two strings by the equals() method. | The StringBuffer class doesn't override the equals() method of the Object class. |
| String class is slower while performing concatenation operations. | StringBuffer class is faster while performing concatenation operations. |
| String class uses String constant pool. | StringBuffer uses Heap memory. |


## Q2. Among StringBuffer and String, if performance is the main constraint, then which one would be preferred, and why?
- If performance is the main constraint, then StringBuffer would be preferred over String because it is mutable, which means that it can be modified without creating a new object every time a modification is made.
- On the other hand, String is immutable, which means that any modifications require creating a new object, which can be time-consuming and memory-intensive.
- StringBuffer has methods like append(), insert(), and replace() which can modify the existing string buffer object without creating a new one. This can significantly improve performance, especially when dealing with large amounts of text.


## Q3. How does String memory allocation work?
In Java, strings are immutable objects, which means that once a string object is created, it cannot be modified. Whenever a string is created in Java, a new string object is created in memory, and the reference to that object is assigned to the string variable.

String memory allocation in Java is managed by the Java Virtual Machine (JVM) using a process called String Interning. When a string is created in Java, the JVM checks to see if there is already an identical string object in the String pool which is an area in Java heap memory. If there is, the JVM assigns the reference of the existing object to the new string variable instead of creating a new object. This process is called interning and helps to reduce memory usage and improve performance.

Here is a complete Example:

```

public class StringMemory {
	public static void main(String[] args) {
		// String literals - Pool
		String str1 = "Hello";
		String str2 = "Hello";
		System.out.println(str1 == str2); // true - references same object in pool
		// New String object - Heap
		String str3 = new String("World");
		String str4 = new String("World");
		System.out.println(str3 == str4); // false - different objects in heap
		// String concatenation - New object
		String message = str1 + " " + str3;
		System.out.println(message == str1); // false - new object created
	}
}

```


## Q4. What are the different ways to create a String in Java?
String objects can be created in two ways:

```

String S = new String("Java Interview Enablement"); // using new operator.

```

```

String S = "Java Interview Enablement"; // using double quotes/Literals.

```

When the String is created with the double quotes/literal values, JVM searches it for in the string pool; if the same value is found, it returns the reference to that String else and creates a new object with the new value provided.

In the other case, if the String is created with the 'new' operator, then JVM creates a new object but not in the string pool. If we want to create the object in the string pool, we can use the intern() method.


## Q5. Why is String immutable in Java?
Immutable means unmodifiable or unchangeable.

Security is the major reason why strings in Java are made to be immutable. Strings in Java can be used to access data sources like files, databases, or even objects found across networks. Even sometimes, strings store passwords and usernames, which can't be modified once created.


## Q6. What is intern() in String?
A String object in the string constant pool is called a String Intern. 

You can create an exact copy of the heap memory string object in the String constant pool. This process of creating an exact copy of the heap memory string object in the string constant pool is called interning. intern() method is used for interning.

Here is a complete Example:

```

public class StringInternExample {
	public static void main(String[] args) {
		String str1 = "Infosys";
		String str2 = new String("Infosys");
		String str3 = str1.intern();
		String str4 = str2.intern();
		// Check object references
		System.out.println(str1 == str2); // false - different object references
		System.out.println(str1 == str3); // true - references point to the same interned string
		System.out.println(str2 == str4); // true - references point to the same interned string (after intern())
		// Check content equality
		System.out.println(str1.equals(str2)); // true -  same content
		System.out.println(str3.equals(str4)); // true -  same content (interned strings)
	}
}

```


## Q7. How does the substring() method fix memory leakage?
- Substring shares the same character array as the String. If the original String is too large, it will lead to a memory leak, and sometimes it will not be retained.

- Then, the original String will be retained by the substring as the size of the substring is smaller than the original String. It will further result in the prevention of large arrays being garbage collected. 

Here is a complete Example:

```

public class SubstringExample {
	  public static void main(String[] args) {
	    String largeString = new String(new char[100000]).replace('\0', 'A');
	    String substring = largeString.substring(0, 10);
	    if (largeString == null || largeString.length() != 0) {
	      System.out.println("Memory leak might occur (depends on Java version)");
	    } else {
	      System.out.println("No memory leak (as expected in Java 7+)");
	    }
	  }
	}
// Output: Memory leak might occur (depends on Java version)

```


## Q8. Consider we define a String in the try block, assign a value and return the same. What happens if we have a finally block and try to modify the same string from within it? 
A compilation error will be generated.

Consider the following code.

```

public class StreamDemo {
    public static void main(String[] args) {
        System.out.println(getString());
    }
    public static String getString() {
        try {
            String originalString = "Hello";
            return originalString; // Return reference to originalString
          } finally {
            try {
              // Generates compilation error as variable is not accessible
              originalString += " World";
            } catch (Exception e) {
              // Statements to handle exception
            }
    }
}

```

The variable ‘originalString’ is created in the try block and assigned the value ‘Hello’. So, the scope of the variable is the try block, and the ‘originalString’ variable will not be available outside the try block, not even in the associated finally block. 


## Q9. What is String constant pool?
In Java, the string constant pool is a special memory area within the heap that stores string literals (sequences of characters enclosed in double quotes). It plays a crucial role in optimizing memory usage and improving string performance.

- String literals are directly placed in the string constant pool when encountered during program compilation.
- If multiple string literals have the same value, only one copy is stored in the pool, and all references to that literal point to the same object. This concept is called string interning.
- When you create a String object using the new keyword with a literal, the JVM first checks the constant pool for an existing String object with the same value.
  - If a match is found, the newly created String object simply references the existing one in the pool.
  - If there's no match, a new String object is created in the heap and added to the constant pool.

**Example:**

```

String str1 = "Hello";
String str2 = "Hello";
String str3 = new String("Hello");
System.out.println(str1 == str2); // true (both reference the same object in the pool)
System.out.println(str1 == str3); // false (str3 creates a new object even though the literal is the same)


````
